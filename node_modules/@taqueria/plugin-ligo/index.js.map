{"mappings":"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","sources":["taqueria-plugin-ligo/index.ts","taqueria-plugin-ligo/createContract.ts","taqueria-plugin-ligo/ligo_templates.ts","taqueria-plugin-ligo/ligo.ts","taqueria-plugin-ligo/compile.ts","taqueria-plugin-ligo/common.ts","taqueria-plugin-ligo/test.ts"],"sourcesContent":["import { Option, Plugin, PositionalArg, Task, Template } from '@taqueria/node-sdk';\nimport createContract from './createContract';\nimport ligo from './ligo';\n\nPlugin.create(i18n => ({\n\tschema: '1.0',\n\tversion: '0.1',\n\talias: 'ligo',\n\ttasks: [\n\t\tTask.create({\n\t\t\ttask: 'compile',\n\t\t\tcommand: 'compile <sourceFile>',\n\t\t\taliases: ['c', 'compile-ligo'],\n\t\t\tdescription:\n\t\t\t\t'Compile a smart contract written in a LIGO syntax to Michelson code, along with its associated storages and parameters files if they are found',\n\t\t\thandler: 'proxy',\n\t\t\tencoding: 'json',\n\t\t}),\n\t\tTask.create({\n\t\t\ttask: 'test',\n\t\t\tcommand: 'test <sourceFile>',\n\t\t\tdescription: 'Test a smart contract written in LIGO',\n\t\t\thandler: 'proxy',\n\t\t\tencoding: 'json',\n\t\t}),\n\t],\n\ttemplates: [\n\t\tTemplate.create({\n\t\t\ttemplate: 'contract',\n\t\t\tcommand: 'contract <sourceFileName>',\n\t\t\tdescription: 'Create a LIGO contract with boilerplate code',\n\t\t\tpositionals: [\n\t\t\t\tPositionalArg.create({\n\t\t\t\t\tplaceholder: 'sourceFileName',\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdescription: 'The name of the LIGO contract to generate',\n\t\t\t\t}),\n\t\t\t],\n\t\t\toptions: [\n\t\t\t\tOption.create({\n\t\t\t\t\tshortFlag: 's',\n\t\t\t\t\tflag: 'syntax',\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdescription: 'The syntax used in the contract',\n\t\t\t\t}),\n\t\t\t],\n\t\t\thandler: createContract,\n\t\t}),\n\t],\n\tproxy: ligo,\n}), process.argv);\n","import { experimental, sendAsyncErr } from '@taqueria/node-sdk';\nimport * as RequestArgs from '@taqueria/protocol/RequestArgs';\nimport { writeFile } from 'fs/promises';\nimport { jsligo_template, mligo_template, pascaligo_template, religo_template } from './ligo_templates';\n\ninterface Opts extends RequestArgs.t {\n\tsourceFileName?: string;\n\tsyntax?: string;\n}\n\nconst registerContract = (arg: Opts, contractName: string) => {\n\texperimental.registerContract(arg, contractName);\n};\n\nconst getLigoTemplate = async (contractName: string, syntax: string | undefined): Promise<string> => {\n\tconst matchResult = contractName.match(/\\.[^.]+$/);\n\tconst ext = matchResult ? matchResult[0].substring(1) : null;\n\n\tif (syntax === 'mligo') return mligo_template;\n\tif (syntax === 'ligo') return pascaligo_template;\n\tif (syntax === 'religo') return religo_template;\n\tif (syntax === 'jsligo') return jsligo_template;\n\n\tif (syntax === undefined) {\n\t\tif (ext === 'mligo') return mligo_template;\n\t\tif (ext === 'ligo') return pascaligo_template;\n\t\tif (ext === 'religo') return religo_template;\n\t\tif (ext === 'jsligo') return jsligo_template;\n\t\treturn sendAsyncErr(\n\t\t\t`Unable to infer LIGO syntax from \"${contractName}\". Please specify a LIGO syntax via the --syntax option`,\n\t\t);\n\t} else {\n\t\treturn sendAsyncErr(`\"${syntax}\" is not a valid syntax. Please specify a valid LIGO syntax`);\n\t}\n};\n\nconst createContract = (arg: Opts) => {\n\tconst contractName = arg.sourceFileName as string;\n\tconst syntax = arg.syntax;\n\tconst contractsDir = `${arg.config.projectDir}/${arg.config.contractsDir}`;\n\treturn getLigoTemplate(contractName, syntax)\n\t\t.then(ligo_template => writeFile(`${contractsDir}/${contractName}`, ligo_template))\n\t\t.then(_ => registerContract(arg, contractName));\n};\n\nexport default createContract;\n","export const mligo_template = `\ntype storage = int\n\ntype parameter =\n  Increment of int\n| Decrement of int\n| Reset\n\ntype return = operation list * storage\n\n// Two entrypoints\n\nlet add (store, delta : storage * int) : storage = store + delta\nlet sub (store, delta : storage * int) : storage = store - delta\n\n(* Main access point that dispatches to the entrypoints according to\n   the smart contract parameter. *)\n   \nlet main (action, store : parameter * storage) : return =\n ([] : operation list),    // No operations\n (match action with\n   Increment (n) -> add (store, n)\n | Decrement (n) -> sub (store, n)\n | Reset         -> 0)\n`;\n\nexport const pascaligo_template = `\ntype storage is int\n\ntype parameter is\n  Increment of int\n| Decrement of int\n| Reset\n\ntype return is list (operation) * storage\n\n// Two entrypoints\n\nfunction add (const store : storage; const delta : int) : storage is \n  store + delta\n\nfunction sub (const store : storage; const delta : int) : storage is \n  store - delta\n\n(* Main access point that dispatches to the entrypoints according to\n   the smart contract parameter. *)\n   \nfunction main (const action : parameter; const store : storage) : return is\n ((nil : list (operation)),    // No operations\n  case action of [\n    Increment (n) -> add (store, n)\n  | Decrement (n) -> sub (store, n)\n  | Reset         -> 0\n  ])\n`;\n\nexport const religo_template = `\ntype storage = int;\n\ntype parameter =\n  Increment (int)\n| Decrement (int)\n| Reset;\n\ntype return = (list (operation), storage);\n\n// Two entrypoints\n\nlet add = ((store, delta) : (storage, int)) : storage => store + delta;\nlet sub = ((store, delta) : (storage, int)) : storage => store - delta;\n\n/* Main access point that dispatches to the entrypoints according to\n   the smart contract parameter. */\n   \nlet main = ((action, store) : (parameter, storage)) : return => {\n (([] : list (operation)),    // No operations\n (switch (action) {\n  | Increment (n) => add ((store, n))\n  | Decrement (n) => sub ((store, n))\n  | Reset         => 0}))\n};\n`;\n\nexport const jsligo_template = `\ntype storage = int;\n\ntype parameter =\n  [\"Increment\", int]\n| [\"Decrement\", int]\n| [\"Reset\"];\n\ntype ret = [list<operation>, storage];\n\n// Two entrypoints\n\nconst add = ([store, delta] : [storage, int]) : storage => store + delta;\nconst sub = ([store, delta] : [storage, int]) : storage => store - delta;\n\n/* Main access point that dispatches to the entrypoints according to\n   the smart contract parameter. */\n\nconst main = ([action, store] : [parameter, storage]) : ret => {\n return [list([]) as list<operation>,    // No operations\n match (action, {\n  Increment:(n: int) => add ([store, n]),\n  Decrement:(n: int) => sub ([store, n]),\n  Reset    :()  => 0})]\n};\n`;\n","import { sendAsyncErr } from '@taqueria/node-sdk';\nimport { IntersectionOpts as Opts } from './common';\nimport compile from './compile';\nimport test from './test';\n\nconst ligo = (parsedArgs: Opts): Promise<void> => {\n\tswitch (parsedArgs.task) {\n\t\tcase 'compile':\n\t\t\treturn compile(parsedArgs);\n\t\tcase 'test':\n\t\t\treturn test(parsedArgs);\n\t\tdefault:\n\t\t\treturn sendAsyncErr(`${parsedArgs.task} is not an understood task by the LIGO plugin`);\n\t}\n};\n\nexport default ligo;\n","import { execCmd, getArch, sendAsyncErr, sendErr, sendJsonRes, sendWarn } from '@taqueria/node-sdk';\nimport { access, readFile, writeFile } from 'fs/promises';\nimport { basename, extname, join } from 'path';\nimport { CompileOpts as Opts, getInputFilename, LIGO_DOCKER_IMAGE } from './common';\n\ntype TableRow = { contract: string; artifact: string };\n\ntype ExprKind = 'storage' | 'default_storage' | 'parameter';\n\nconst COMPILE_ERR_MSG: string = 'Not compiled';\n\nconst isStorageKind = (exprKind: ExprKind): boolean => exprKind === 'storage' || exprKind === 'default_storage';\n\nconst isLIGOFile = (sourceFile: string): boolean => /.+\\.(ligo|religo|mligo|jsligo)$/.test(sourceFile);\n\nconst isStoragesFile = (sourceFile: string): boolean => /.+\\.storages\\.(ligo|religo|mligo|jsligo)$/.test(sourceFile);\n\nconst isParametersFile = (sourceFile: string): boolean =>\n\t/.+\\.parameters\\.(ligo|religo|mligo|jsligo)$/.test(sourceFile);\n\nconst isContractFile = (sourceFile: string): boolean =>\n\tisLIGOFile(sourceFile) && !isStoragesFile(sourceFile) && !isParametersFile(sourceFile);\n\nconst extractExt = (path: string): string => {\n\tconst matchResult = path.match(/\\.(ligo|religo|mligo|jsligo)$/);\n\treturn matchResult ? matchResult[0] : '';\n};\n\nconst removeExt = (path: string): string => {\n\tconst extRegex = new RegExp(extractExt(path));\n\treturn path.replace(extRegex, '');\n};\n\nconst getOutputFilename = (parsedArgs: Opts, sourceFile: string): string => {\n\tconst outputFile = basename(sourceFile, extname(sourceFile));\n\treturn join(parsedArgs.config.artifactsDir, `${outputFile}.tz`);\n};\n\n// Get the contract name that the storage/parameter file is associated with\n// e.g. If sourceFile is token.storages.mligo, then it'll return token.mligo\nconst getContractNameForExpr = (sourceFile: string, exprKind: ExprKind): string => {\n\ttry {\n\t\treturn isStorageKind(exprKind)\n\t\t\t? sourceFile.match(/.+(?=\\.storages\\.(ligo|religo|mligo|jsligo))/)!.join('.')\n\t\t\t: sourceFile.match(/.+(?=\\.parameters\\.(ligo|religo|mligo|jsligo))/)!.join('.');\n\t} catch (err) {\n\t\tthrow new Error(`Something went wrong internally when dealing with filename format: ${err}`);\n\t}\n};\n\n// If sourceFile is token.storages.mligo, then it'll return token.storage.{storageName}.tz\nconst getOutputExprFileName = (parsedArgs: Opts, sourceFile: string, exprKind: ExprKind, exprName: string): string => {\n\tconst contractName = basename(getContractNameForExpr(sourceFile, exprKind), extname(sourceFile));\n\tconst outputFile = exprKind === 'default_storage'\n\t\t? `${contractName}.default_storage.tz`\n\t\t: `${contractName}.${exprKind}.${exprName}.tz`;\n\treturn join(parsedArgs.config.artifactsDir, `${outputFile}`);\n};\n\nconst getCompileContractCmd = (parsedArgs: Opts, sourceFile: string): string => {\n\tconst projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;\n\tif (!projectDir) throw `No project directory provided`;\n\tconst baseCmd =\n\t\t`DOCKER_DEFAULT_PLATFORM=linux/amd64 docker run --rm -v \\\"${projectDir}\\\":/project -w /project -u $(id -u):$(id -g) ${LIGO_DOCKER_IMAGE} compile contract`;\n\tconst inputFile = getInputFilename(parsedArgs, sourceFile);\n\tconst outputFile = `-o ${getOutputFilename(parsedArgs, sourceFile)}`;\n\tconst cmd = `${baseCmd} ${inputFile} ${outputFile}`;\n\treturn cmd;\n};\n\nconst getCompileExprCmd = (parsedArgs: Opts, sourceFile: string, exprKind: ExprKind, exprName: string): string => {\n\tconst projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;\n\tif (!projectDir) throw `No project directory provided`;\n\tconst compilerType = isStorageKind(exprKind) ? 'storage' : 'parameter';\n\tconst baseCmd =\n\t\t`DOCKER_DEFAULT_PLATFORM=linux/amd64 docker run --rm -v \\\"${projectDir}\\\":/project -w /project -u $(id -u):$(id -g) ${LIGO_DOCKER_IMAGE} compile ${compilerType}`;\n\tconst inputFile = getInputFilename(parsedArgs, sourceFile);\n\tconst outputFile = `-o ${getOutputExprFileName(parsedArgs, sourceFile, exprKind, exprName)}`;\n\tconst cmd = `${baseCmd} ${inputFile} ${exprName} ${outputFile}`;\n\treturn cmd;\n};\n\nconst compileContract = (parsedArgs: Opts, sourceFile: string): Promise<TableRow> =>\n\tgetArch()\n\t\t.then(() => getCompileContractCmd(parsedArgs, sourceFile))\n\t\t.then(execCmd)\n\t\t.then(({ stderr }) => {\n\t\t\tif (stderr.length > 0) sendWarn(stderr);\n\t\t\treturn {\n\t\t\t\tcontract: sourceFile,\n\t\t\t\tartifact: getOutputFilename(parsedArgs, sourceFile),\n\t\t\t};\n\t\t})\n\t\t.catch(err => {\n\t\t\tsendErr(`\\n=== For ${sourceFile} ===`);\n\t\t\tsendErr(err.message.replace(/Command failed.+?\\n/, ''));\n\t\t\treturn {\n\t\t\t\tcontract: sourceFile,\n\t\t\t\tartifact: COMPILE_ERR_MSG,\n\t\t\t};\n\t\t});\n\nconst compileExpr = (parsedArgs: Opts, sourceFile: string, exprKind: ExprKind) =>\n\t(exprName: string): Promise<TableRow> =>\n\t\tgetArch()\n\t\t\t.then(() => getCompileExprCmd(parsedArgs, sourceFile, exprKind, exprName))\n\t\t\t.then(execCmd)\n\t\t\t.then(({ stderr }) => {\n\t\t\t\tif (stderr.length > 0) sendWarn(stderr);\n\t\t\t\treturn {\n\t\t\t\t\tcontract: sourceFile,\n\t\t\t\t\tartifact: getOutputExprFileName(parsedArgs, sourceFile, exprKind, exprName),\n\t\t\t\t};\n\t\t\t})\n\t\t\t.catch(err => {\n\t\t\t\tsendErr(`\\n=== For ${sourceFile} ===`);\n\t\t\t\tsendErr(err.message.replace(/Command failed.+?\\n/, ''));\n\t\t\t\treturn {\n\t\t\t\t\tcontract: sourceFile,\n\t\t\t\t\tartifact: COMPILE_ERR_MSG,\n\t\t\t\t};\n\t\t\t});\n\nconst compileExprs = (parsedArgs: Opts, sourceFile: string, exprKind: ExprKind): Promise<TableRow[]> =>\n\treadFile(getInputFilename(parsedArgs, sourceFile), 'utf8')\n\t\t.then(data => {\n\t\t\tif (!data.includes('#include')) {\n\t\t\t\twriteFile(\n\t\t\t\t\tgetInputFilename(parsedArgs, sourceFile),\n\t\t\t\t\t`#include \"${getContractNameForExpr(sourceFile, exprKind)}\"\\n` + data,\n\t\t\t\t\t'utf8',\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn data;\n\t\t})\n\t\t.then(data => data.match(/(?<=\\s*(let|const)\\s+)[a-zA-Z0-9_]+/g))\n\t\t.then(exprNames => {\n\t\t\tif (!exprNames) return [];\n\t\t\tconst firstExprName = exprNames.slice(0, 1)[0];\n\t\t\tconst restExprNames = exprNames.slice(1, exprNames.length);\n\t\t\tconst firstExprKind = isStorageKind(exprKind) ? 'default_storage' : 'parameter';\n\t\t\tconst restExprKind = isStorageKind(exprKind) ? 'storage' : 'parameter';\n\t\t\tconst firstExprResult = compileExpr(parsedArgs, sourceFile, firstExprKind)(firstExprName);\n\t\t\tconst restExprResults = restExprNames.map(compileExpr(parsedArgs, sourceFile, restExprKind));\n\t\t\treturn Promise.all([firstExprResult].concat(restExprResults));\n\t\t})\n\t\t.catch(err => {\n\t\t\tsendErr(`\\n=== For ${sourceFile} ===`);\n\t\t\tsendErr(err.message);\n\t\t\treturn [{\n\t\t\t\tcontract: sourceFile,\n\t\t\t\tartifact: `No ${isStorageKind(exprKind) ? 'storages' : 'parameters'} compiled`,\n\t\t\t}];\n\t\t})\n\t\t.then(mergeArtifactsOutput(sourceFile));\n\nconst compileContractWithStorageAndParameter = async (parsedArgs: Opts, sourceFile: string): Promise<TableRow[]> => {\n\tconst contractCompileResult = await compileContract(parsedArgs, sourceFile);\n\tif (contractCompileResult.artifact === COMPILE_ERR_MSG) return [contractCompileResult];\n\n\tconst storagesFile = `${removeExt(sourceFile)}.storages${extractExt(sourceFile)}`;\n\tconst parametersFile = `${removeExt(sourceFile)}.parameters${extractExt(sourceFile)}`;\n\tconst storagesFilename = getInputFilename(parsedArgs, storagesFile);\n\tconst parametersFilename = getInputFilename(parsedArgs, parametersFile);\n\n\tconst storageCompileResult = await access(storagesFilename)\n\t\t.then(() => compileExprs(parsedArgs, storagesFile, 'storage'))\n\t\t.catch(() => {\n\t\t\t// sendWarn(\n\t\t\t// \t`Note: storage file associated with \"${sourceFile}\" can't be found. You should create a file \"${storagesFile}\" and define initial storage values as a list of LIGO variable definitions. e.g. \"let STORAGE_NAME: storage = LIGO_EXPR\" for CameLigo`,\n\t\t\t// )\n\t\t});\n\n\tconst parameterCompileResult = await access(parametersFilename)\n\t\t.then(() => compileExprs(parsedArgs, parametersFile, 'parameter'))\n\t\t.catch(() => {\n\t\t\t// sendWarn(\n\t\t\t// \t`Note: parameter file associated with \"${sourceFile}\" can't be found. You should create a file \"${parametersFile}\" and define parameter values as a list of LIGO variable definitions. e.g. \"let PARAMETER_NAME: parameter = LIGO_EXPR\" for CameLigo`,\n\t\t\t// )\n\t\t});\n\n\tlet compileResults: TableRow[] = [contractCompileResult];\n\tif (storageCompileResult) compileResults = compileResults.concat(storageCompileResult);\n\tif (parameterCompileResult) compileResults = compileResults.concat(parameterCompileResult);\n\treturn compileResults;\n};\n\n/*\nCompiling storage/parameter file amounts to compiling multiple expressions in that file,\nresulting in multiple rows with the same file name but different artifact names.\nThis will merge these rows into one row with just one mention of the file name.\ne.g.\n┌──────────────────────┬─────────────────────────────────────────────┐\n│ Contract             │ Artifact                                    │\n├──────────────────────┼─────────────────────────────────────────────┤\n│ hello.storages.mligo │ artifacts/hello.default_storage.storage1.tz │\n├──────────────────────┼─────────────────────────────────────────────┤\n│ hello.storages.mligo │ artifacts/hello.storage.storage2.tz         │\n└──────────────────────┴─────────────────────────────────────────────┘\n\t\t\t\t\t\t\t\tversus\n┌──────────────────────┬─────────────────────────────────────────────┐\n│ Contract             │ Artifact                                    │\n├──────────────────────┼─────────────────────────────────────────────┤\n│ hello.storages.mligo │ artifacts/hello.default_storage.storage1.tz │\n│                      │ artifacts/hello.storage.storage2.tz         │\n└──────────────────────┴─────────────────────────────────────────────┘\n*/\nconst mergeArtifactsOutput = (sourceFile: string) =>\n\t(tableRows: TableRow[]): TableRow[] => {\n\t\tconst artifactsOutput = tableRows.reduce(\n\t\t\t(acc: string, row: TableRow) => row.artifact === COMPILE_ERR_MSG ? acc : `${acc}${row.artifact}\\n`,\n\t\t\t'',\n\t\t);\n\t\treturn [{\n\t\t\tcontract: sourceFile,\n\t\t\tartifact: artifactsOutput,\n\t\t}];\n\t};\n\nconst compile = (parsedArgs: Opts): Promise<void> => {\n\tconst sourceFile = parsedArgs.sourceFile;\n\tlet p: Promise<TableRow[]>;\n\tif (isStoragesFile(sourceFile)) p = compileExprs(parsedArgs, sourceFile, 'storage');\n\telse if (isParametersFile(sourceFile)) p = compileExprs(parsedArgs, sourceFile, 'parameter');\n\telse if (isContractFile(sourceFile)) p = compileContractWithStorageAndParameter(parsedArgs, sourceFile);\n\telse {\n\t\treturn sendAsyncErr(\n\t\t\t`${sourceFile} doesn't have a valid LIGO extension ('.ligo', '.religo', '.mligo' or '.jsligo')`,\n\t\t);\n\t}\n\treturn p.then(sendJsonRes).catch(err => sendAsyncErr(err, false));\n};\n\nexport default compile;\n","import { RequestArgs } from '@taqueria/node-sdk/types';\nimport { join } from 'path';\n\nexport interface CompileOpts extends RequestArgs.ProxyRequestArgs {\n\tsourceFile: string;\n}\n\nexport interface TestOpts extends RequestArgs.ProxyRequestArgs {\n\tsourceFile: string;\n}\n\nexport type IntersectionOpts = CompileOpts & TestOpts;\n\ntype UnionOpts = CompileOpts | TestOpts;\n\n// Points to the latest stable version. Needs to update this as part of our release process\nexport const LIGO_DOCKER_IMAGE = 'ligolang/ligo:0.51.0';\n\nexport const getInputFilename = (parsedArgs: UnionOpts, sourceFile: string): string =>\n\tjoin(parsedArgs.config.contractsDir, sourceFile);\n","import { execCmd, getArch, sendAsyncErr, sendErr, sendJsonRes, sendWarn } from '@taqueria/node-sdk';\nimport { getInputFilename, LIGO_DOCKER_IMAGE, TestOpts as Opts } from './common';\n\ntype TableRow = { contract: string; testResults: string };\n\nconst getTestContractCmd = (parsedArgs: Opts, sourceFile: string): string => {\n\tconst projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;\n\tif (!projectDir) throw `No project directory provided`;\n\tconst baseCmd =\n\t\t`DOCKER_DEFAULT_PLATFORM=linux/amd64 docker run --rm -v \\\"${projectDir}\\\":/project -w /project -u $(id -u):$(id -g) ${LIGO_DOCKER_IMAGE} run test`;\n\tconst inputFile = getInputFilename(parsedArgs, sourceFile);\n\tconst cmd = `${baseCmd} ${inputFile}`;\n\treturn cmd;\n};\n\nconst testContract = (parsedArgs: Opts, sourceFile: string): Promise<TableRow> =>\n\tgetArch()\n\t\t.then(() => getTestContractCmd(parsedArgs, sourceFile))\n\t\t.then(execCmd)\n\t\t.then(({ stdout, stderr }) => {\n\t\t\tif (stderr.length > 0) sendWarn(stderr);\n\t\t\tconst result = '🎉 All tests passed 🎉';\n\t\t\treturn {\n\t\t\t\tcontract: sourceFile,\n\t\t\t\ttestResults: stdout.length > 0 ? `${stdout}\\n${result}` : result,\n\t\t\t};\n\t\t})\n\t\t.catch(err => {\n\t\t\tsendErr(`\\n=== For ${sourceFile} ===`);\n\t\t\tsendErr(err.message.replace(/Command failed.+?\\n/, ''));\n\t\t\treturn {\n\t\t\t\tcontract: sourceFile,\n\t\t\t\ttestResults: 'Some tests failed :(',\n\t\t\t};\n\t\t});\n\nconst test = (parsedArgs: Opts): Promise<void> => {\n\tconst sourceFile = parsedArgs.sourceFile;\n\treturn testContract(parsedArgs, sourceFile).then(result => [result]).then(sendJsonRes).catch(err =>\n\t\tsendAsyncErr(err, false)\n\t);\n};\n\nexport default test;\n"],"names":[],"version":3,"file":"index.js.map","sourceRoot":"../"}