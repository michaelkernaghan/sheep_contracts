var $kQNfl$taquerianodesdk = require("@taqueria/node-sdk");
var $kQNfl$fspromises = require("fs/promises");
var $kQNfl$path = require("path");




const $9d8c61104c8e60ad$export$1336661d942c7074 = `
type storage = int

type parameter =
  Increment of int
| Decrement of int
| Reset

type return = operation list * storage

// Two entrypoints

let add (store, delta : storage * int) : storage = store + delta
let sub (store, delta : storage * int) : storage = store - delta

(* Main access point that dispatches to the entrypoints according to
   the smart contract parameter. *)
   
let main (action, store : parameter * storage) : return =
 ([] : operation list),    // No operations
 (match action with
   Increment (n) -> add (store, n)
 | Decrement (n) -> sub (store, n)
 | Reset         -> 0)
`;
const $9d8c61104c8e60ad$export$ec41334b92330d9b = `
type storage is int

type parameter is
  Increment of int
| Decrement of int
| Reset

type return is list (operation) * storage

// Two entrypoints

function add (const store : storage; const delta : int) : storage is 
  store + delta

function sub (const store : storage; const delta : int) : storage is 
  store - delta

(* Main access point that dispatches to the entrypoints according to
   the smart contract parameter. *)
   
function main (const action : parameter; const store : storage) : return is
 ((nil : list (operation)),    // No operations
  case action of [
    Increment (n) -> add (store, n)
  | Decrement (n) -> sub (store, n)
  | Reset         -> 0
  ])
`;
const $9d8c61104c8e60ad$export$9e59f1f7960689be = `
type storage = int;

type parameter =
  Increment (int)
| Decrement (int)
| Reset;

type return = (list (operation), storage);

// Two entrypoints

let add = ((store, delta) : (storage, int)) : storage => store + delta;
let sub = ((store, delta) : (storage, int)) : storage => store - delta;

/* Main access point that dispatches to the entrypoints according to
   the smart contract parameter. */
   
let main = ((action, store) : (parameter, storage)) : return => {
 (([] : list (operation)),    // No operations
 (switch (action) {
  | Increment (n) => add ((store, n))
  | Decrement (n) => sub ((store, n))
  | Reset         => 0}))
};
`;
const $9d8c61104c8e60ad$export$6d35abb7f92d1079 = `
type storage = int;

type parameter =
  ["Increment", int]
| ["Decrement", int]
| ["Reset"];

type ret = [list<operation>, storage];

// Two entrypoints

const add = ([store, delta] : [storage, int]) : storage => store + delta;
const sub = ([store, delta] : [storage, int]) : storage => store - delta;

/* Main access point that dispatches to the entrypoints according to
   the smart contract parameter. */

const main = ([action, store] : [parameter, storage]) : ret => {
 return [list([]) as list<operation>,    // No operations
 match (action, {
  Increment:(n: int) => add ([store, n]),
  Decrement:(n: int) => sub ([store, n]),
  Reset    :()  => 0})]
};
`;


const $40622e3a438d0515$var$registerContract = (arg, contractName)=>{
    (0, $kQNfl$taquerianodesdk.experimental).registerContract(arg, contractName);
};
const $40622e3a438d0515$var$getLigoTemplate = async (contractName, syntax)=>{
    const matchResult = contractName.match(/\.[^.]+$/);
    const ext = matchResult ? matchResult[0].substring(1) : null;
    if (syntax === "mligo") return 0, $9d8c61104c8e60ad$export$1336661d942c7074;
    if (syntax === "ligo") return 0, $9d8c61104c8e60ad$export$ec41334b92330d9b;
    if (syntax === "religo") return 0, $9d8c61104c8e60ad$export$9e59f1f7960689be;
    if (syntax === "jsligo") return 0, $9d8c61104c8e60ad$export$6d35abb7f92d1079;
    if (syntax === undefined) {
        if (ext === "mligo") return 0, $9d8c61104c8e60ad$export$1336661d942c7074;
        if (ext === "ligo") return 0, $9d8c61104c8e60ad$export$ec41334b92330d9b;
        if (ext === "religo") return 0, $9d8c61104c8e60ad$export$9e59f1f7960689be;
        if (ext === "jsligo") return 0, $9d8c61104c8e60ad$export$6d35abb7f92d1079;
        return (0, $kQNfl$taquerianodesdk.sendAsyncErr)(`Unable to infer LIGO syntax from "${contractName}". Please specify a LIGO syntax via the --syntax option`);
    } else return (0, $kQNfl$taquerianodesdk.sendAsyncErr)(`"${syntax}" is not a valid syntax. Please specify a valid LIGO syntax`);
};
const $40622e3a438d0515$var$createContract = (arg)=>{
    const contractName = arg.sourceFileName;
    const syntax = arg.syntax;
    const contractsDir = `${arg.config.projectDir}/${arg.config.contractsDir}`;
    return $40622e3a438d0515$var$getLigoTemplate(contractName, syntax).then((ligo_template)=>(0, $kQNfl$fspromises.writeFile)(`${contractsDir}/${contractName}`, ligo_template)).then((_)=>$40622e3a438d0515$var$registerContract(arg, contractName));
};
var $40622e3a438d0515$export$2e2bcd8739ae039 = $40622e3a438d0515$var$createContract;







const $844cb58d66fbf6db$export$9bb5edf1683d4462 = "ligolang/ligo:0.51.0";
const $844cb58d66fbf6db$export$17f107107c3c82c6 = (parsedArgs, sourceFile)=>(0, $kQNfl$path.join)(parsedArgs.config.contractsDir, sourceFile);


const $24b2f47d8f306cb3$var$COMPILE_ERR_MSG = "Not compiled";
const $24b2f47d8f306cb3$var$isStorageKind = (exprKind)=>exprKind === "storage" || exprKind === "default_storage";
const $24b2f47d8f306cb3$var$isLIGOFile = (sourceFile)=>/.+\.(ligo|religo|mligo|jsligo)$/.test(sourceFile);
const $24b2f47d8f306cb3$var$isStoragesFile = (sourceFile)=>/.+\.storages\.(ligo|religo|mligo|jsligo)$/.test(sourceFile);
const $24b2f47d8f306cb3$var$isParametersFile = (sourceFile)=>/.+\.parameters\.(ligo|religo|mligo|jsligo)$/.test(sourceFile);
const $24b2f47d8f306cb3$var$isContractFile = (sourceFile)=>$24b2f47d8f306cb3$var$isLIGOFile(sourceFile) && !$24b2f47d8f306cb3$var$isStoragesFile(sourceFile) && !$24b2f47d8f306cb3$var$isParametersFile(sourceFile);
const $24b2f47d8f306cb3$var$extractExt = (path)=>{
    const matchResult = path.match(/\.(ligo|religo|mligo|jsligo)$/);
    return matchResult ? matchResult[0] : "";
};
const $24b2f47d8f306cb3$var$removeExt = (path)=>{
    const extRegex = new RegExp($24b2f47d8f306cb3$var$extractExt(path));
    return path.replace(extRegex, "");
};
const $24b2f47d8f306cb3$var$getOutputFilename = (parsedArgs, sourceFile)=>{
    const outputFile = (0, $kQNfl$path.basename)(sourceFile, (0, $kQNfl$path.extname)(sourceFile));
    return (0, $kQNfl$path.join)(parsedArgs.config.artifactsDir, `${outputFile}.tz`);
};
// Get the contract name that the storage/parameter file is associated with
// e.g. If sourceFile is token.storages.mligo, then it'll return token.mligo
const $24b2f47d8f306cb3$var$getContractNameForExpr = (sourceFile, exprKind)=>{
    try {
        return $24b2f47d8f306cb3$var$isStorageKind(exprKind) ? sourceFile.match(/.+(?=\.storages\.(ligo|religo|mligo|jsligo))/).join(".") : sourceFile.match(/.+(?=\.parameters\.(ligo|religo|mligo|jsligo))/).join(".");
    } catch (err) {
        throw new Error(`Something went wrong internally when dealing with filename format: ${err}`);
    }
};
// If sourceFile is token.storages.mligo, then it'll return token.storage.{storageName}.tz
const $24b2f47d8f306cb3$var$getOutputExprFileName = (parsedArgs, sourceFile, exprKind, exprName)=>{
    const contractName = (0, $kQNfl$path.basename)($24b2f47d8f306cb3$var$getContractNameForExpr(sourceFile, exprKind), (0, $kQNfl$path.extname)(sourceFile));
    const outputFile = exprKind === "default_storage" ? `${contractName}.default_storage.tz` : `${contractName}.${exprKind}.${exprName}.tz`;
    return (0, $kQNfl$path.join)(parsedArgs.config.artifactsDir, `${outputFile}`);
};
const $24b2f47d8f306cb3$var$getCompileContractCmd = (parsedArgs, sourceFile)=>{
    const projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;
    if (!projectDir) throw `No project directory provided`;
    const baseCmd = `DOCKER_DEFAULT_PLATFORM=linux/amd64 docker run --rm -v \"${projectDir}\":/project -w /project -u $(id -u):$(id -g) ${(0, $844cb58d66fbf6db$export$9bb5edf1683d4462)} compile contract`;
    const inputFile = (0, $844cb58d66fbf6db$export$17f107107c3c82c6)(parsedArgs, sourceFile);
    const outputFile = `-o ${$24b2f47d8f306cb3$var$getOutputFilename(parsedArgs, sourceFile)}`;
    const cmd = `${baseCmd} ${inputFile} ${outputFile}`;
    return cmd;
};
const $24b2f47d8f306cb3$var$getCompileExprCmd = (parsedArgs, sourceFile, exprKind, exprName)=>{
    const projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;
    if (!projectDir) throw `No project directory provided`;
    const compilerType = $24b2f47d8f306cb3$var$isStorageKind(exprKind) ? "storage" : "parameter";
    const baseCmd = `DOCKER_DEFAULT_PLATFORM=linux/amd64 docker run --rm -v \"${projectDir}\":/project -w /project -u $(id -u):$(id -g) ${(0, $844cb58d66fbf6db$export$9bb5edf1683d4462)} compile ${compilerType}`;
    const inputFile = (0, $844cb58d66fbf6db$export$17f107107c3c82c6)(parsedArgs, sourceFile);
    const outputFile = `-o ${$24b2f47d8f306cb3$var$getOutputExprFileName(parsedArgs, sourceFile, exprKind, exprName)}`;
    const cmd = `${baseCmd} ${inputFile} ${exprName} ${outputFile}`;
    return cmd;
};
const $24b2f47d8f306cb3$var$compileContract = (parsedArgs, sourceFile)=>(0, $kQNfl$taquerianodesdk.getArch)().then(()=>$24b2f47d8f306cb3$var$getCompileContractCmd(parsedArgs, sourceFile)).then((0, $kQNfl$taquerianodesdk.execCmd)).then(({ stderr: stderr  })=>{
        if (stderr.length > 0) (0, $kQNfl$taquerianodesdk.sendWarn)(stderr);
        return {
            contract: sourceFile,
            artifact: $24b2f47d8f306cb3$var$getOutputFilename(parsedArgs, sourceFile)
        };
    }).catch((err)=>{
        (0, $kQNfl$taquerianodesdk.sendErr)(`\n=== For ${sourceFile} ===`);
        (0, $kQNfl$taquerianodesdk.sendErr)(err.message.replace(/Command failed.+?\n/, ""));
        return {
            contract: sourceFile,
            artifact: $24b2f47d8f306cb3$var$COMPILE_ERR_MSG
        };
    });
const $24b2f47d8f306cb3$var$compileExpr = (parsedArgs, sourceFile, exprKind)=>(exprName)=>(0, $kQNfl$taquerianodesdk.getArch)().then(()=>$24b2f47d8f306cb3$var$getCompileExprCmd(parsedArgs, sourceFile, exprKind, exprName)).then((0, $kQNfl$taquerianodesdk.execCmd)).then(({ stderr: stderr  })=>{
            if (stderr.length > 0) (0, $kQNfl$taquerianodesdk.sendWarn)(stderr);
            return {
                contract: sourceFile,
                artifact: $24b2f47d8f306cb3$var$getOutputExprFileName(parsedArgs, sourceFile, exprKind, exprName)
            };
        }).catch((err)=>{
            (0, $kQNfl$taquerianodesdk.sendErr)(`\n=== For ${sourceFile} ===`);
            (0, $kQNfl$taquerianodesdk.sendErr)(err.message.replace(/Command failed.+?\n/, ""));
            return {
                contract: sourceFile,
                artifact: $24b2f47d8f306cb3$var$COMPILE_ERR_MSG
            };
        });
const $24b2f47d8f306cb3$var$compileExprs = (parsedArgs, sourceFile, exprKind)=>(0, $kQNfl$fspromises.readFile)((0, $844cb58d66fbf6db$export$17f107107c3c82c6)(parsedArgs, sourceFile), "utf8").then((data)=>{
        if (!data.includes("#include")) (0, $kQNfl$fspromises.writeFile)((0, $844cb58d66fbf6db$export$17f107107c3c82c6)(parsedArgs, sourceFile), `#include "${$24b2f47d8f306cb3$var$getContractNameForExpr(sourceFile, exprKind)}"\n` + data, "utf8");
        return data;
    }).then((data)=>data.match(/(?<=\s*(let|const)\s+)[a-zA-Z0-9_]+/g)).then((exprNames)=>{
        if (!exprNames) return [];
        const firstExprName = exprNames.slice(0, 1)[0];
        const restExprNames = exprNames.slice(1, exprNames.length);
        const firstExprKind = $24b2f47d8f306cb3$var$isStorageKind(exprKind) ? "default_storage" : "parameter";
        const restExprKind = $24b2f47d8f306cb3$var$isStorageKind(exprKind) ? "storage" : "parameter";
        const firstExprResult = $24b2f47d8f306cb3$var$compileExpr(parsedArgs, sourceFile, firstExprKind)(firstExprName);
        const restExprResults = restExprNames.map($24b2f47d8f306cb3$var$compileExpr(parsedArgs, sourceFile, restExprKind));
        return Promise.all([
            firstExprResult
        ].concat(restExprResults));
    }).catch((err)=>{
        (0, $kQNfl$taquerianodesdk.sendErr)(`\n=== For ${sourceFile} ===`);
        (0, $kQNfl$taquerianodesdk.sendErr)(err.message);
        return [
            {
                contract: sourceFile,
                artifact: `No ${$24b2f47d8f306cb3$var$isStorageKind(exprKind) ? "storages" : "parameters"} compiled`
            }
        ];
    }).then($24b2f47d8f306cb3$var$mergeArtifactsOutput(sourceFile));
const $24b2f47d8f306cb3$var$compileContractWithStorageAndParameter = async (parsedArgs, sourceFile)=>{
    const contractCompileResult = await $24b2f47d8f306cb3$var$compileContract(parsedArgs, sourceFile);
    if (contractCompileResult.artifact === $24b2f47d8f306cb3$var$COMPILE_ERR_MSG) return [
        contractCompileResult
    ];
    const storagesFile = `${$24b2f47d8f306cb3$var$removeExt(sourceFile)}.storages${$24b2f47d8f306cb3$var$extractExt(sourceFile)}`;
    const parametersFile = `${$24b2f47d8f306cb3$var$removeExt(sourceFile)}.parameters${$24b2f47d8f306cb3$var$extractExt(sourceFile)}`;
    const storagesFilename = (0, $844cb58d66fbf6db$export$17f107107c3c82c6)(parsedArgs, storagesFile);
    const parametersFilename = (0, $844cb58d66fbf6db$export$17f107107c3c82c6)(parsedArgs, parametersFile);
    const storageCompileResult = await (0, $kQNfl$fspromises.access)(storagesFilename).then(()=>$24b2f47d8f306cb3$var$compileExprs(parsedArgs, storagesFile, "storage")).catch(()=>{
    // sendWarn(
    // 	`Note: storage file associated with "${sourceFile}" can't be found. You should create a file "${storagesFile}" and define initial storage values as a list of LIGO variable definitions. e.g. "let STORAGE_NAME: storage = LIGO_EXPR" for CameLigo`,
    // )
    });
    const parameterCompileResult = await (0, $kQNfl$fspromises.access)(parametersFilename).then(()=>$24b2f47d8f306cb3$var$compileExprs(parsedArgs, parametersFile, "parameter")).catch(()=>{
    // sendWarn(
    // 	`Note: parameter file associated with "${sourceFile}" can't be found. You should create a file "${parametersFile}" and define parameter values as a list of LIGO variable definitions. e.g. "let PARAMETER_NAME: parameter = LIGO_EXPR" for CameLigo`,
    // )
    });
    let compileResults = [
        contractCompileResult
    ];
    if (storageCompileResult) compileResults = compileResults.concat(storageCompileResult);
    if (parameterCompileResult) compileResults = compileResults.concat(parameterCompileResult);
    return compileResults;
};
/*
Compiling storage/parameter file amounts to compiling multiple expressions in that file,
resulting in multiple rows with the same file name but different artifact names.
This will merge these rows into one row with just one mention of the file name.
e.g.
┌──────────────────────┬─────────────────────────────────────────────┐
│ Contract             │ Artifact                                    │
├──────────────────────┼─────────────────────────────────────────────┤
│ hello.storages.mligo │ artifacts/hello.default_storage.storage1.tz │
├──────────────────────┼─────────────────────────────────────────────┤
│ hello.storages.mligo │ artifacts/hello.storage.storage2.tz         │
└──────────────────────┴─────────────────────────────────────────────┘
								versus
┌──────────────────────┬─────────────────────────────────────────────┐
│ Contract             │ Artifact                                    │
├──────────────────────┼─────────────────────────────────────────────┤
│ hello.storages.mligo │ artifacts/hello.default_storage.storage1.tz │
│                      │ artifacts/hello.storage.storage2.tz         │
└──────────────────────┴─────────────────────────────────────────────┘
*/ const $24b2f47d8f306cb3$var$mergeArtifactsOutput = (sourceFile)=>(tableRows)=>{
        const artifactsOutput = tableRows.reduce((acc, row)=>row.artifact === $24b2f47d8f306cb3$var$COMPILE_ERR_MSG ? acc : `${acc}${row.artifact}\n`, "");
        return [
            {
                contract: sourceFile,
                artifact: artifactsOutput
            }
        ];
    };
const $24b2f47d8f306cb3$var$compile = (parsedArgs)=>{
    const sourceFile = parsedArgs.sourceFile;
    let p;
    if ($24b2f47d8f306cb3$var$isStoragesFile(sourceFile)) p = $24b2f47d8f306cb3$var$compileExprs(parsedArgs, sourceFile, "storage");
    else if ($24b2f47d8f306cb3$var$isParametersFile(sourceFile)) p = $24b2f47d8f306cb3$var$compileExprs(parsedArgs, sourceFile, "parameter");
    else if ($24b2f47d8f306cb3$var$isContractFile(sourceFile)) p = $24b2f47d8f306cb3$var$compileContractWithStorageAndParameter(parsedArgs, sourceFile);
    else return (0, $kQNfl$taquerianodesdk.sendAsyncErr)(`${sourceFile} doesn't have a valid LIGO extension ('.ligo', '.religo', '.mligo' or '.jsligo')`);
    return p.then((0, $kQNfl$taquerianodesdk.sendJsonRes)).catch((err)=>(0, $kQNfl$taquerianodesdk.sendAsyncErr)(err, false));
};
var $24b2f47d8f306cb3$export$2e2bcd8739ae039 = $24b2f47d8f306cb3$var$compile;




const $8d09eb70c0505719$var$getTestContractCmd = (parsedArgs, sourceFile)=>{
    const projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;
    if (!projectDir) throw `No project directory provided`;
    const baseCmd = `DOCKER_DEFAULT_PLATFORM=linux/amd64 docker run --rm -v \"${projectDir}\":/project -w /project -u $(id -u):$(id -g) ${(0, $844cb58d66fbf6db$export$9bb5edf1683d4462)} run test`;
    const inputFile = (0, $844cb58d66fbf6db$export$17f107107c3c82c6)(parsedArgs, sourceFile);
    const cmd = `${baseCmd} ${inputFile}`;
    return cmd;
};
const $8d09eb70c0505719$var$testContract = (parsedArgs, sourceFile)=>(0, $kQNfl$taquerianodesdk.getArch)().then(()=>$8d09eb70c0505719$var$getTestContractCmd(parsedArgs, sourceFile)).then((0, $kQNfl$taquerianodesdk.execCmd)).then(({ stdout: stdout , stderr: stderr  })=>{
        if (stderr.length > 0) (0, $kQNfl$taquerianodesdk.sendWarn)(stderr);
        const result = "\uD83C\uDF89 All tests passed \uD83C\uDF89";
        return {
            contract: sourceFile,
            testResults: stdout.length > 0 ? `${stdout}\n${result}` : result
        };
    }).catch((err)=>{
        (0, $kQNfl$taquerianodesdk.sendErr)(`\n=== For ${sourceFile} ===`);
        (0, $kQNfl$taquerianodesdk.sendErr)(err.message.replace(/Command failed.+?\n/, ""));
        return {
            contract: sourceFile,
            testResults: "Some tests failed :("
        };
    });
const $8d09eb70c0505719$var$test = (parsedArgs)=>{
    const sourceFile = parsedArgs.sourceFile;
    return $8d09eb70c0505719$var$testContract(parsedArgs, sourceFile).then((result)=>[
            result
        ]).then((0, $kQNfl$taquerianodesdk.sendJsonRes)).catch((err)=>(0, $kQNfl$taquerianodesdk.sendAsyncErr)(err, false));
};
var $8d09eb70c0505719$export$2e2bcd8739ae039 = $8d09eb70c0505719$var$test;


const $0be740342372c80a$var$ligo = (parsedArgs)=>{
    switch(parsedArgs.task){
        case "compile":
            return (0, $24b2f47d8f306cb3$export$2e2bcd8739ae039)(parsedArgs);
        case "test":
            return (0, $8d09eb70c0505719$export$2e2bcd8739ae039)(parsedArgs);
        default:
            return (0, $kQNfl$taquerianodesdk.sendAsyncErr)(`${parsedArgs.task} is not an understood task by the LIGO plugin`);
    }
};
var $0be740342372c80a$export$2e2bcd8739ae039 = $0be740342372c80a$var$ligo;


(0, $kQNfl$taquerianodesdk.Plugin).create((i18n)=>({
        schema: "1.0",
        version: "0.1",
        alias: "ligo",
        tasks: [
            (0, $kQNfl$taquerianodesdk.Task).create({
                task: "compile",
                command: "compile <sourceFile>",
                aliases: [
                    "c",
                    "compile-ligo"
                ],
                description: "Compile a smart contract written in a LIGO syntax to Michelson code, along with its associated storages and parameters files if they are found",
                handler: "proxy",
                encoding: "json"
            }),
            (0, $kQNfl$taquerianodesdk.Task).create({
                task: "test",
                command: "test <sourceFile>",
                description: "Test a smart contract written in LIGO",
                handler: "proxy",
                encoding: "json"
            }), 
        ],
        templates: [
            (0, $kQNfl$taquerianodesdk.Template).create({
                template: "contract",
                command: "contract <sourceFileName>",
                description: "Create a LIGO contract with boilerplate code",
                positionals: [
                    (0, $kQNfl$taquerianodesdk.PositionalArg).create({
                        placeholder: "sourceFileName",
                        type: "string",
                        description: "The name of the LIGO contract to generate"
                    }), 
                ],
                options: [
                    (0, $kQNfl$taquerianodesdk.Option).create({
                        shortFlag: "s",
                        flag: "syntax",
                        type: "string",
                        description: "The syntax used in the contract"
                    }), 
                ],
                handler: (0, $40622e3a438d0515$export$2e2bcd8739ae039)
            }), 
        ],
        proxy: (0, $0be740342372c80a$export$2e2bcd8739ae039)
    }), process.argv);


//# sourceMappingURL=index.js.map
