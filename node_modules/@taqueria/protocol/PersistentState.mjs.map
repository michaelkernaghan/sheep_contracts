{"version":3,"sources":["PersistentState.ts"],"sourcesContent":["import createType from '@taqueria/protocol/Base';\nimport * as SHA256 from '@taqueria/protocol/SHA256';\nimport * as Timestamp from '@taqueria/protocol/Timestamp';\nimport * as Verb from '@taqueria/protocol/Verb';\nimport { z } from 'zod';\n\nconst rawOpSchema = z.object({\n\thash: SHA256.rawSchema.describe('state.op.hash'),\n\ttime: Timestamp.rawSchema.describe('state.op.time'),\n\toutput: z.unknown().describe('state.op.output'),\n}).describe('Persistent State Operation');\n\nconst rawTaskSchema = z.object({\n\ttask: Verb.schemas.rawSchema,\n\tplugin: z.string().min(1),\n\ttime: Timestamp.rawSchema.describe('state.task.time'),\n\toutput: z.unknown().describe('state.task.output'),\n});\n\nconst internalOpSchema = z.object({\n\thash: SHA256.schemas.schema.describe('state.op.hash'),\n\ttime: Timestamp.schemas.schema.describe('state.op.time'),\n\toutput: z.unknown().describe('state.op.output'),\n});\n\nconst internalTaskSchema = z.object({\n\ttask: Verb.schemas.schema,\n\tplugin: z.string().min(1),\n\ttime: Timestamp.schemas.schema.describe('state.task.time'),\n\toutput: z.unknown().describe('state.op.output'),\n});\n\nexport type PersistedTask = z.infer<typeof internalTaskSchema>;\n\nexport type PersistedOperation = z.infer<typeof internalOpSchema>;\n\nexport const rawSchema = z.object({\n\toperations: z.record(rawOpSchema),\n\ttasks: z.record(rawTaskSchema),\n});\n\nexport const internalSchema = z.object({\n\toperations: z.record(internalOpSchema),\n\ttasks: z.record(internalTaskSchema),\n}).transform(val => ({\n\toperations: val.operations as unknown as Record<string, PersistedOperation>,\n\ttasks: val.tasks as unknown as Record<string, PersistedTask>,\n}));\n\ntype RawInput = z.infer<typeof rawSchema>;\n\ntype Input = z.infer<typeof internalSchema>;\n\nexport const { schemas: generatedSchemas, factory } = createType<RawInput, Input>({\n\trawSchema,\n\tparseErrMsg: `The persistent state is invalid`,\n\tunknownErrMsg: `Something went wrong trying to parse the persistent state`,\n});\n\nexport type PersistentState = z.infer<typeof generatedSchemas.schema>;\nexport type t = PersistentState;\nexport type State = PersistentState;\n\nexport const { create, of, make } = factory;\n\nexport const schemas = {\n\t...generatedSchemas,\n\tschema: generatedSchemas.schema.transform(val => val as unknown as PersistentState),\n};\n"],"mappings":";AAAA,OAAO,gBAAgB;AACvB,YAAY,YAAY;AACxB,YAAY,eAAe;AAC3B,YAAY,UAAU;AACtB,SAAS,SAAS;AAElB,IAAM,cAAc,EAAE,OAAO;AAAA,EAC5B,MAAa,iBAAU,SAAS,eAAe;AAAA,EAC/C,MAAgB,oBAAU,SAAS,eAAe;AAAA,EAClD,QAAQ,EAAE,QAAQ,EAAE,SAAS,iBAAiB;AAC/C,CAAC,EAAE,SAAS,4BAA4B;AAExC,IAAM,gBAAgB,EAAE,OAAO;AAAA,EAC9B,MAAW,aAAQ;AAAA,EACnB,QAAQ,EAAE,OAAO,EAAE,IAAI,CAAC;AAAA,EACxB,MAAgB,oBAAU,SAAS,iBAAiB;AAAA,EACpD,QAAQ,EAAE,QAAQ,EAAE,SAAS,mBAAmB;AACjD,CAAC;AAED,IAAM,mBAAmB,EAAE,OAAO;AAAA,EACjC,MAAa,eAAQ,OAAO,SAAS,eAAe;AAAA,EACpD,MAAgB,kBAAQ,OAAO,SAAS,eAAe;AAAA,EACvD,QAAQ,EAAE,QAAQ,EAAE,SAAS,iBAAiB;AAC/C,CAAC;AAED,IAAM,qBAAqB,EAAE,OAAO;AAAA,EACnC,MAAW,aAAQ;AAAA,EACnB,QAAQ,EAAE,OAAO,EAAE,IAAI,CAAC;AAAA,EACxB,MAAgB,kBAAQ,OAAO,SAAS,iBAAiB;AAAA,EACzD,QAAQ,EAAE,QAAQ,EAAE,SAAS,iBAAiB;AAC/C,CAAC;AAMM,IAAMA,aAAY,EAAE,OAAO;AAAA,EACjC,YAAY,EAAE,OAAO,WAAW;AAAA,EAChC,OAAO,EAAE,OAAO,aAAa;AAC9B,CAAC;AAEM,IAAM,iBAAiB,EAAE,OAAO;AAAA,EACtC,YAAY,EAAE,OAAO,gBAAgB;AAAA,EACrC,OAAO,EAAE,OAAO,kBAAkB;AACnC,CAAC,EAAE,UAAU,UAAQ;AAAA,EACpB,YAAY,IAAI;AAAA,EAChB,OAAO,IAAI;AACZ,EAAE;AAMK,IAAM,EAAE,SAAS,kBAAkB,QAAQ,IAAI,WAA4B;AAAA,EACjF,WAAAA;AAAA,EACA,aAAa;AAAA,EACb,eAAe;AAChB,CAAC;AAMM,IAAM,EAAE,QAAQ,IAAI,KAAK,IAAI;AAE7B,IAAMC,WAAU;AAAA,EACtB,GAAG;AAAA,EACH,QAAQ,iBAAiB,OAAO,UAAU,SAAO,GAAiC;AACnF;","names":["rawSchema","schemas"]}