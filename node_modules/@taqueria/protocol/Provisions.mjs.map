{"version":3,"sources":["Provisions.ts"],"sourcesContent":["import createType, { Flatten } from '@taqueria/protocol/Base';\nimport * as Provisioner from '@taqueria/protocol/Provisioner';\nimport * as ProvisionerID from '@taqueria/protocol/ProvisionerID';\nimport { uniq } from 'rambda';\nimport { memoize, partition } from 'rambdax';\nimport { z } from 'zod';\n\nconst getInvalidIds = memoize(\n\t(provisions: (Provisioner.t | Provisioner.Input | Provisioner.RawInput)[]): ProvisionerID.t[] => {\n\t\tconst ids = provisions.map(p => p.id);\n\t\treturn provisions.reduce(\n\t\t\t(retval, provision) => {\n\t\t\t\tconst depends_on = (provision.depends_on ?? []) as unknown as ProvisionerID.t[];\n\t\t\t\tconst results = partition(\n\t\t\t\t\t(id: ProvisionerID.t) => ids.includes(id),\n\t\t\t\t\tdepends_on,\n\t\t\t\t) as unknown[][];\n\t\t\t\tconst invalid = results.pop() as ProvisionerID.t[];\n\n\t\t\t\treturn uniq([...retval, ...invalid]);\n\t\t\t},\n\t\t\t[] as ProvisionerID.t[],\n\t\t);\n\t},\n);\n\nconst rawSchema = z\n\t.array(\n\t\tProvisioner.rawSchema,\n\t)\n\t.refine(\n\t\tprovisions => getInvalidIds(provisions).length === 0,\n\t\tprovisions => ({\n\t\t\tmessage:\n\t\t\t\t`One or more of your provisioners depends on an invalid provisioner. The following provisioner ids were referenced that do not exist: ${\n\t\t\t\t\tgetInvalidIds(provisions).join(', ')\n\t\t\t\t}`,\n\t\t}),\n\t)\n\t.describe('Provisions');\n\ntype RawInput = z.infer<typeof rawSchema>;\n\nconst internalSchema = z\n\t.array(Provisioner.schemas.schema)\n\t.refine(\n\t\tprovisions => getInvalidIds(provisions).length === 0,\n\t\tprovisions => ({\n\t\t\tmessage:\n\t\t\t\t`One or more of your provisioners depends on an invalid provisioner. The following provisioner ids were referenced that do not exist: ${\n\t\t\t\t\tgetInvalidIds(provisions).join(', ')\n\t\t\t\t}`,\n\t\t}),\n\t)\n\t.describe('Provisions');\n\ntype Input = z.infer<typeof internalSchema>;\n\nexport const { schemas: generatedSchemas, factory } = createType<RawInput, Input>({\n\trawSchema,\n\tinternalSchema,\n\tparseErrMsg: (value: unknown) => `The following provision is invalid: ${value}`,\n\tunknownErrMsg: 'Something went wrong parsing the list of provisioners',\n});\n\nexport type Provisions = Flatten<z.infer<typeof generatedSchemas.schema>>;\nexport type t = Provisions;\nexport const { create, of, make } = factory;\n\nexport const schemas = {\n\t...generatedSchemas,\n\tschema: generatedSchemas.schema.transform(val => val as Provisions),\n};\n"],"mappings":";AAAA,OAAO,gBAA6B;AACpC,YAAY,iBAAiB;AAE7B,SAAS,YAAY;AACrB,SAAS,SAAS,iBAAiB;AACnC,SAAS,SAAS;AAElB,IAAM,gBAAgB;AAAA,EACrB,CAAC,eAAgG;AAChG,UAAM,MAAM,WAAW,IAAI,OAAK,EAAE,EAAE;AACpC,WAAO,WAAW;AAAA,MACjB,CAAC,QAAQ,cAAc;AACtB,cAAM,aAAc,UAAU,cAAc,CAAC;AAC7C,cAAM,UAAU;AAAA,UACf,CAAC,OAAwB,IAAI,SAAS,EAAE;AAAA,UACxC;AAAA,QACD;AACA,cAAM,UAAU,QAAQ,IAAI;AAE5B,eAAO,KAAK,CAAC,GAAG,QAAQ,GAAG,OAAO,CAAC;AAAA,MACpC;AAAA,MACA,CAAC;AAAA,IACF;AAAA,EACD;AACD;AAEA,IAAMA,aAAY,EAChB;AAAA,EACY;AACb,EACC;AAAA,EACA,gBAAc,cAAc,UAAU,EAAE,WAAW;AAAA,EACnD,iBAAe;AAAA,IACd,SACC,wIACC,cAAc,UAAU,EAAE,KAAK,IAAI;AAAA,EAEtC;AACD,EACC,SAAS,YAAY;AAIvB,IAAM,iBAAiB,EACrB,MAAkB,oBAAQ,MAAM,EAChC;AAAA,EACA,gBAAc,cAAc,UAAU,EAAE,WAAW;AAAA,EACnD,iBAAe;AAAA,IACd,SACC,wIACC,cAAc,UAAU,EAAE,KAAK,IAAI;AAAA,EAEtC;AACD,EACC,SAAS,YAAY;AAIhB,IAAM,EAAE,SAAS,kBAAkB,QAAQ,IAAI,WAA4B;AAAA,EACjF,WAAAA;AAAA,EACA;AAAA,EACA,aAAa,CAAC,UAAmB,uCAAuC;AAAA,EACxE,eAAe;AAChB,CAAC;AAIM,IAAM,EAAE,QAAQ,IAAI,KAAK,IAAI;AAE7B,IAAMC,WAAU;AAAA,EACtB,GAAG;AAAA,EACH,QAAQ,iBAAiB,OAAO,UAAU,SAAO,GAAiB;AACnE;","names":["rawSchema","schemas"]}