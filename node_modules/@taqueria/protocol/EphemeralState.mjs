// EphemeralState.ts
import createType from "@taqueria/protocol/Base";
import * as Command from "@taqueria/protocol/Command";
import * as InstalledPlugin from "@taqueria/protocol/InstalledPlugin";
import * as Option from "@taqueria/protocol/Option";
import * as ParsedOperation from "@taqueria/protocol/ParsedOperation";
import * as ParsedTemplate from "@taqueria/protocol/ParsedTemplate";
import * as PluginInfo from "@taqueria/protocol/PluginInfo";
import * as PluginResponseEncoding from "@taqueria/protocol/PluginResponseEncoding";
import { E_TaqError } from "@taqueria/protocol/TaqError";
import * as Task from "@taqueria/protocol/Task";
import * as Verb from "@taqueria/protocol/Verb";
import { attemptP, mapRej, promise } from "fluture";
import { z } from "zod";
var eager = (f) => promise(
  mapRej((err) => new E_TaqError(err))(f)
);
var taskToPluginMap = z.record(
  z.union([
    InstalledPlugin.schemas.schema,
    Task.schemas.schema
  ], { description: "Task/Plugin Mapping" })
);
var operationToPluginMap = z.record(
  z.union([
    InstalledPlugin.schemas.schema,
    ParsedOperation.schemas.schema
  ], { description: "Operation/Plugin Mapping" })
);
var templateToPluginMap = z.record(
  z.union([
    InstalledPlugin.schemas.schema,
    ParsedTemplate.schemas.schema
  ])
);
var rawSchema = z.object({
  build: z.string({ description: "cache.build" }),
  configHash: z.string({ description: "cache.configHash" }),
  tasks: taskToPluginMap,
  operations: operationToPluginMap,
  templates: templateToPluginMap,
  plugins: z.array(PluginInfo.schemas.schema, { description: "cache.plugins" })
}).describe("Ephemeral State");
var { schemas: generatedSchemas, factory } = createType({
  rawSchema,
  parseErrMsg: (value) => `${value} is not a valid representation of ephemeral state`,
  unknownErrMsg: "Something went wrong when parsing the ephemeral state"
});
var { create: create2, of, make: make7 } = factory;
var schemas6 = {
  ...generatedSchemas,
  schema: generatedSchemas.schema.transform((val) => val)
};
var getTaskCounts = (pluginInfo) => {
  return pluginInfo.reduce(
    (retval, pluginInfo2) => pluginInfo2.tasks === void 0 ? {} : pluginInfo2.tasks.reduce(
      (retval2, task) => {
        const taskName = task.task;
        const providers = retval2[taskName] ? [...retval2[taskName], pluginInfo2] : [pluginInfo2];
        const mapping = {};
        mapping[taskName] = providers.filter((provider) => provider !== void 0);
        return { ...retval2, ...mapping };
      },
      retval
    ),
    {}
  );
};
var getTemplateCounts = (pluginInfo) => {
  return pluginInfo.reduce(
    (retval, pluginInfo2) => !pluginInfo2.templates ? retval : pluginInfo2.templates.reduce(
      (retval2, template) => {
        const templateName = template.template;
        const providers = retval2[templateName] ? [...retval2[templateName], pluginInfo2] : [pluginInfo2];
        const mapping = {};
        mapping[templateName] = providers.filter((provider) => provider !== void 0);
        return { ...retval2, ...mapping };
      },
      retval
    ),
    {}
  );
};
var getOperationCounts = (pluginInfo) => {
  return pluginInfo.reduce(
    (retval, pluginInfo2) => pluginInfo2.operations === void 0 ? retval : pluginInfo2.operations.reduce(
      (retval2, operation) => {
        const operationName = operation.operation;
        const providers = retval2[operationName] ? [...retval2[operationName], pluginInfo2] : [pluginInfo2];
        const mapping = {};
        mapping[operationName] = providers.filter((provider) => provider !== void 0);
        return { ...retval2, ...mapping };
      },
      retval
    ),
    {}
  );
};
var toChoices = (plugins) => plugins.reduce(
  (retval, pluginInfo) => {
    return [...retval, pluginInfo.name, pluginInfo.alias];
  },
  []
);
var isComposite = (name, counts) => counts[name] && counts[name].length > 1;
var getInstalledPlugin = (config, name) => {
  var _a;
  return (_a = config.plugins) == null ? void 0 : _a.find(
    (plugin) => [`taqueria-plugin-${name}`, name].includes(plugin.name)
  );
};
var mapTasksToPlugins = (config, pluginInfo, i18n) => {
  const taskCounts = getTaskCounts(pluginInfo);
  return attemptP(
    async () => await pluginInfo.reduce(
      async (retval, pluginInfo2) => !pluginInfo2.tasks ? Promise.resolve({}) : await pluginInfo2.tasks.reduce(
        async (retval2, { task }) => {
          if (isComposite(task, taskCounts)) {
            const command = await eager(Command.make(task));
            const compositeTask = await eager(Task.make({
              task,
              command,
              description: i18n.__("providedByMany"),
              hidden: false,
              options: [
                await eager(Option.make({
                  flag: await eager(Verb.make("plugin")),
                  description: "Specify which plugin should be used to execute this task",
                  choices: toChoices(taskCounts[task]),
                  required: true
                }))
              ],
              handler: "proxy"
            }));
            return { ...await retval2, [task]: compositeTask };
          }
          const installedPlugin = getInstalledPlugin(config, pluginInfo2.name);
          return installedPlugin ? { ...await retval2, [task]: installedPlugin } : retval2;
        },
        retval
      ),
      Promise.resolve({})
    )
  ).pipe(mapRej((rej) => rej));
};
var mapOperationsToPlugins = (config, pluginInfo, i18n) => {
  const opCounts = getOperationCounts(pluginInfo);
  return attemptP(
    async () => await pluginInfo.reduce(
      async (retval, pluginInfo2) => !pluginInfo2.operations ? Promise.resolve({}) : await pluginInfo2.operations.reduce(
        async (retval2, { operation }) => {
          if (isComposite(operation, opCounts)) {
            const command = await eager(Command.make(operation));
            const compositeOp = await eager(ParsedOperation.make({
              operation,
              command,
              description: i18n.__("providedByMany"),
              options: [
                await eager(Option.make({
                  flag: await eager(Verb.make("plugin")),
                  description: "Specify which plugin should be used to execute this operation",
                  choices: toChoices(opCounts[operation]),
                  required: true
                }))
              ]
            }));
            return { ...await retval2, [operation]: compositeOp };
          }
          const installedPlugin = getInstalledPlugin(config, pluginInfo2.name);
          return installedPlugin ? { ...await retval2, [operation]: installedPlugin } : retval2;
        },
        retval
      ),
      Promise.resolve({})
    )
  ).pipe(mapRej((rej) => rej));
};
var mapTemplatesToPlugins = (config, pluginInfo, i18n) => {
  const tmplCounts = getTemplateCounts(pluginInfo);
  return attemptP(
    async () => await pluginInfo.reduce(
      async (retval, pluginInfo2) => !pluginInfo2.templates ? Promise.resolve({}) : await pluginInfo2.templates.reduce(
        async (retval2, { template }) => {
          if (isComposite(template, tmplCounts)) {
            const command = await eager(Command.make(template));
            const compositeTmpl = await eager(ParsedTemplate.make({
              template,
              command,
              description: i18n.__("providedByMany"),
              options: [
                await eager(Option.make({
                  flag: await eager(Verb.make("plugin")),
                  description: "Specify which plugin should be used to execute this task",
                  choices: toChoices(tmplCounts[template]),
                  required: true
                }))
              ],
              handler: "proxy",
              encoding: PluginResponseEncoding.create("none")
            }));
            return { ...await retval2, [template]: compositeTmpl };
          }
          const installedPlugin = getInstalledPlugin(config, pluginInfo2.name);
          return installedPlugin ? { ...await retval2, [template]: installedPlugin } : retval2;
        },
        retval
      ),
      Promise.resolve({})
    )
  ).pipe(mapRej((rej) => rej));
};
var getTasks = (pluginInfo) => pluginInfo.reduce(
  (retval, pluginInfo2) => [...retval, ...pluginInfo2.tasks ?? []],
  []
);
export {
  create2 as create,
  factory,
  generatedSchemas,
  getTasks,
  make7 as make,
  mapOperationsToPlugins,
  mapTasksToPlugins,
  mapTemplatesToPlugins,
  of,
  schemas6 as schemas
};
//# sourceMappingURL=EphemeralState.mjs.map