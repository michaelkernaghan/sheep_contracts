import { FutureInstance } from 'fluture';
import { z, ZodSchema } from 'zod';
declare type ErrMsg = string | ((value: unknown, previous?: unknown) => string);
interface CreateSchemaParams {
    rawSchema: ZodSchema;
    internalSchema?: ZodSchema;
    transformer?: (value: unknown) => unknown;
    isStringLike?: boolean;
}
interface CreateTypeParams extends CreateSchemaParams {
    parseErrMsg: ErrMsg;
    unknownErrMsg: ErrMsg;
}
export declare type Flatten<T> = {
    [k in keyof T]: T[k];
};
export declare const createSchema: <I>(params: CreateSchemaParams) => {
    rawSchema: z.ZodType<any, z.ZodTypeDef, any>;
    internalSchema: z.ZodType<any, z.ZodTypeDef, any>;
    schema: z.ZodEffects<z.ZodType<any, z.ZodTypeDef, any>, I & {
        readonly __kind: any;
    }, any>;
};
export declare const createType: <R, I>(params: CreateTypeParams) => {
    schemas: {
        rawSchema: z.ZodType<any, z.ZodTypeDef, any>;
        internalSchema: z.ZodType<any, z.ZodTypeDef, any>;
        schema: z.ZodEffects<z.ZodType<any, z.ZodTypeDef, any>, I & {
            readonly __kind: any;
        }, any>;
    };
    factory: {
        make: (input: I) => FutureInstance<import("@taqueria/protocol/TaqError").TaqError, I & {
            readonly __kind: any;
        }>;
        of: (input: unknown) => FutureInstance<import("@taqueria/protocol/TaqError").TaqError, I & {
            readonly __kind: any;
        }>;
        create: (input: R | I) => I & {
            readonly __kind: any;
        };
        from: (input: unknown) => I & {
            readonly __kind: any;
        };
    };
};
export default createType;
//# sourceMappingURL=Base.d.ts.map