import { z } from 'zod';
export declare const rawSchema: z.ZodEffects<z.ZodOptional<z.ZodDefault<z.ZodUnion<[z.ZodLiteral<"json">, z.ZodLiteral<"application/json">, z.ZodLiteral<"none">]>>>, "none" | "json" | "application/json" | undefined, unknown>;
export declare const schemas: {
    rawSchema: z.ZodType<any, z.ZodTypeDef, any>;
    internalSchema: z.ZodType<any, z.ZodTypeDef, any>;
    schema: z.ZodEffects<z.ZodType<any, z.ZodTypeDef, any>, ("none" | "json" | "application/json" | undefined) & {
        readonly __kind: any;
    }, any>;
}, factory: {
    make: (input: "none" | "json" | "application/json" | undefined) => import("fluture").FutureInstance<import("./TaqError").TaqError, ("none" | "json" | "application/json" | undefined) & {
        readonly __kind: any;
    }>;
    of: (input: unknown) => import("fluture").FutureInstance<import("./TaqError").TaqError, ("none" | "json" | "application/json" | undefined) & {
        readonly __kind: any;
    }>;
    create: (input: "none" | "json" | "application/json" | undefined) => ("none" | "json" | "application/json" | undefined) & {
        readonly __kind: any;
    };
    from: (input: unknown) => ("none" | "json" | "application/json" | undefined) & {
        readonly __kind: any;
    };
};
export declare type PluginResponseEncoding = z.infer<typeof schemas.schema>;
export declare type t = PluginResponseEncoding;
export declare const create: (input: "none" | "json" | "application/json" | undefined) => ("none" | "json" | "application/json" | undefined) & {
    readonly __kind: any;
}, of: (input: unknown) => import("fluture").FutureInstance<import("./TaqError").TaqError, ("none" | "json" | "application/json" | undefined) & {
    readonly __kind: any;
}>, make: (input: "none" | "json" | "application/json" | undefined) => import("fluture").FutureInstance<import("./TaqError").TaqError, ("none" | "json" | "application/json" | undefined) & {
    readonly __kind: any;
}>;
//# sourceMappingURL=PluginResponseEncoding.d.ts.map