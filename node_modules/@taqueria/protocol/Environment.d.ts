import { Flatten } from '@taqueria/protocol/Base';
import { z } from 'zod';
export declare const rawSchema: z.ZodObject<{
    networks: z.ZodArray<z.ZodString, "many">;
    sandboxes: z.ZodArray<z.ZodString, "many">;
    storage: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
    aliases: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
}, "strip", z.ZodTypeAny, {
    storage?: Record<string, any> | undefined;
    aliases?: Record<string, any> | undefined;
    networks: string[];
    sandboxes: string[];
}, {
    storage?: Record<string, any> | undefined;
    aliases?: Record<string, any> | undefined;
    networks: string[];
    sandboxes: string[];
}>;
export declare const generatedSchemas: {
    rawSchema: z.ZodType<any, z.ZodTypeDef, any>;
    internalSchema: z.ZodType<any, z.ZodTypeDef, any>;
    schema: z.ZodEffects<z.ZodType<any, z.ZodTypeDef, any>, {
        storage?: Record<string, any> | undefined;
        aliases?: Record<string, any> | undefined;
        networks: string[];
        sandboxes: string[];
    } & {
        readonly __kind: any;
    }, any>;
}, factory: {
    make: (input: {
        storage?: Record<string, any> | undefined;
        aliases?: Record<string, any> | undefined;
        networks: string[];
        sandboxes: string[];
    }) => import("fluture").FutureInstance<import("./TaqError").TaqError, {
        storage?: Record<string, any> | undefined;
        aliases?: Record<string, any> | undefined;
        networks: string[];
        sandboxes: string[];
    } & {
        readonly __kind: any;
    }>;
    of: (input: unknown) => import("fluture").FutureInstance<import("./TaqError").TaqError, {
        storage?: Record<string, any> | undefined;
        aliases?: Record<string, any> | undefined;
        networks: string[];
        sandboxes: string[];
    } & {
        readonly __kind: any;
    }>;
    create: (input: {
        storage?: Record<string, any> | undefined;
        aliases?: Record<string, any> | undefined;
        networks: string[];
        sandboxes: string[];
    }) => {
        storage?: Record<string, any> | undefined;
        aliases?: Record<string, any> | undefined;
        networks: string[];
        sandboxes: string[];
    } & {
        readonly __kind: any;
    };
    from: (input: unknown) => {
        storage?: Record<string, any> | undefined;
        aliases?: Record<string, any> | undefined;
        networks: string[];
        sandboxes: string[];
    } & {
        readonly __kind: any;
    };
};
export declare type Environment = Flatten<z.infer<typeof generatedSchemas.schema>>;
export declare type t = Environment;
export declare const create: (input: {
    storage?: Record<string, any> | undefined;
    aliases?: Record<string, any> | undefined;
    networks: string[];
    sandboxes: string[];
}) => {
    storage?: Record<string, any> | undefined;
    aliases?: Record<string, any> | undefined;
    networks: string[];
    sandboxes: string[];
} & {
    readonly __kind: any;
}, make: (input: {
    storage?: Record<string, any> | undefined;
    aliases?: Record<string, any> | undefined;
    networks: string[];
    sandboxes: string[];
}) => import("fluture").FutureInstance<import("./TaqError").TaqError, {
    storage?: Record<string, any> | undefined;
    aliases?: Record<string, any> | undefined;
    networks: string[];
    sandboxes: string[];
} & {
    readonly __kind: any;
}>, of: (input: unknown) => import("fluture").FutureInstance<import("./TaqError").TaqError, {
    storage?: Record<string, any> | undefined;
    aliases?: Record<string, any> | undefined;
    networks: string[];
    sandboxes: string[];
} & {
    readonly __kind: any;
}>, from: (input: unknown) => {
    storage?: Record<string, any> | undefined;
    aliases?: Record<string, any> | undefined;
    networks: string[];
    sandboxes: string[];
} & {
    readonly __kind: any;
};
export declare const schemas: {
    schema: z.ZodEffects<z.ZodEffects<z.ZodType<any, z.ZodTypeDef, any>, {
        storage?: Record<string, any> | undefined;
        aliases?: Record<string, any> | undefined;
        networks: string[];
        sandboxes: string[];
    } & {
        readonly __kind: any;
    }, any>, Flatten<{
        storage?: Record<string, any> | undefined;
        aliases?: Record<string, any> | undefined;
        networks: string[];
        sandboxes: string[];
    } & {
        readonly __kind: any;
    }>, any>;
    rawSchema: z.ZodType<any, z.ZodTypeDef, any>;
    internalSchema: z.ZodType<any, z.ZodTypeDef, any>;
};
//# sourceMappingURL=Environment.d.ts.map