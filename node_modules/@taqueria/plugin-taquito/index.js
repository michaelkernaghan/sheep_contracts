var $iVZbm$taquerianodesdk = require("@taqueria/node-sdk");
var $iVZbm$taquitosigner = require("@taquito/signer");
var $iVZbm$taquitotaquito = require("@taquito/taquito");
var $iVZbm$fspromises = require("fs/promises");
var $iVZbm$path = require("path");
var $iVZbm$taquitomichelcodec = require("@taquito/michel-codec");








const $806c5c6032403442$var$getFirstAccountAlias = (sandboxName, opts)=>{
    const aliases = (0, $iVZbm$taquerianodesdk.getSandboxAccountNames)(opts)(sandboxName);
    return aliases.shift();
};
const $806c5c6032403442$var$getContractAbspath = (contractFilename, parsedArgs)=>(0, $iVZbm$path.join)(parsedArgs.config.artifactsDir, /\.tz$/.test(contractFilename) ? contractFilename : `${contractFilename}.tz`);
const $806c5c6032403442$var$addOrigination = (parsedArgs, batch)=>async (mapping)=>{
        const contractAbspath = $806c5c6032403442$var$getContractAbspath(mapping.filename, parsedArgs);
        const contractData = await (0, $iVZbm$fspromises.readFile)(contractAbspath, "utf-8");
        return (await batch).withOrigination({
            code: contractData,
            init: mapping.storage
        });
    };
const $806c5c6032403442$var$getDefaultStorageFilename = (contractName)=>{
    const baseFilename = (0, $iVZbm$path.basename)(contractName, (0, $iVZbm$path.extname)(contractName));
    const extFilename = (0, $iVZbm$path.extname)(contractName);
    const defaultStorage = `${baseFilename}.default_storage${extFilename}`;
    return defaultStorage;
};
// TODO: temporary quick solution. May refactor this to only deal with one contract later
const $806c5c6032403442$var$getValidContracts = async (parsedArgs)=>{
    const contracts = [
        parsedArgs.contract
    ];
    const storageFilename = parsedArgs.storage ?? $806c5c6032403442$var$getDefaultStorageFilename(contracts[0]);
    return contracts.reduce(async (retval, filename)=>{
        const storage = await (0, $iVZbm$taquerianodesdk.newGetInitialStorage)(parsedArgs, storageFilename);
        if (storage === undefined || storage === null) {
            (0, $iVZbm$taquerianodesdk.sendErr)(`❌ No initial storage file was found for ${filename}\nStorage must be specified in a file as a Michelson expression and will automatically be linked to this contract if specified with the name "${$806c5c6032403442$var$getDefaultStorageFilename(contracts[0])}" in the artifacts directory\nYou can also manually pass a storage file to the deploy task using the --storage STORAGE_FILE_NAME option\n`);
            // sendErr(
            // 	`Michelson artifact ${filename} has no initial storage specified for the target environment.\nStorage is expected to be specified in .taq/config.json at JSON path: environment.${
            // 		getCurrentEnvironment(parsedArgs)
            // 	}.storage["${filename}"]\nThe value of the above JSON key should be the name of the file (absolute path or relative path with respect to the root of the Taqueria project) that contains the actual value of the storage, as a Michelson expression.\n`,
            // );
            return retval;
        }
        return [
            ...await retval,
            {
                filename: filename,
                storage: storage
            }
        ];
    }, Promise.resolve([]));
};
const $806c5c6032403442$var$mapOpToContract = async (parsedArgs, contracts, op, destination)=>{
    const results = await op.operationResults();
    const originationResults = results.filter((result)=>result.kind === "origination").map((result)=>result);
    return contracts.reduce((retval, contract)=>{
        // If initial storage was provided for the contract
        // then we submitted an operation to originate that contract
        if (contract.storage) {
            // WARNING - using side effect here.
            // For each iteration of reduce, results array is being modified-in-place.
            // TODO: Adjust to use recursion to avoid side-effect.
            const result = originationResults.shift();
            const address = result && result.metadata.operation_result.originated_contracts ? result.metadata.operation_result.originated_contracts.join(",") : "Error";
            const alias = parsedArgs.alias ?? (0, $iVZbm$path.basename)(contract.filename, (0, $iVZbm$path.extname)(contract.filename));
            if (address !== "Error") (0, $iVZbm$taquerianodesdk.updateAddressAlias)(parsedArgs, alias, address);
            return [
                ...retval,
                {
                    contract: contract.filename,
                    address: address,
                    alias: address !== "Error" ? alias : "N/A",
                    destination: destination
                }, 
            ];
        }
        return [
            ...retval,
            {
                contract: contract.filename,
                address: "Error",
                alias: "N/A",
                destination: destination
            }, 
        ];
    }, []);
};
const $806c5c6032403442$var$createBatch = async (parsedArgs, tezos, destination)=>{
    const contracts = await $806c5c6032403442$var$getValidContracts(parsedArgs);
    if (!contracts.length) return undefined;
    const batch1 = await contracts.reduce((batch, contractMapping)=>contractMapping.storage ? $806c5c6032403442$var$addOrigination(parsedArgs, batch)(contractMapping) : batch, Promise.resolve(tezos.wallet.batch()));
    try {
        const op = await batch1.send();
        const confirmed = await op.confirmation();
        return await $806c5c6032403442$var$mapOpToContract(parsedArgs, contracts, op, destination);
    } catch (err) {
        const error = err;
        if (error.message) {
            const msg = error.message;
            if (/ENOTFOUND/.test(msg)) (0, $iVZbm$taquerianodesdk.sendErr)(msg + " - The RPC URL may be invalid. Check ./taq/config.json.\n");
            else if (/ECONNREFUSED/.test(msg)) (0, $iVZbm$taquerianodesdk.sendErr)(msg + " - The RPC URL may be down or the sandbox is not running.");
            else if (/empty_implicit_contract/.test(msg)) {
                const result = msg.match(/(?<="implicit":")tz[^"]+(?=")/);
                const publicKeyHash = result ? result[0] : undefined;
                if (!publicKeyHash) (0, $iVZbm$taquerianodesdk.sendErr)(msg);
                else (0, $iVZbm$taquerianodesdk.sendErr)(`The account ${publicKeyHash} for the target environment, "${(0, $iVZbm$taquerianodesdk.getCurrentEnvironment)(parsedArgs)}", may not be funded\nTo fund this account:\n1. Go to https://teztnets.xyz and click "Faucet" of the target testnet\n2. Copy and paste the above key into the 'wallet address field\n3. Request some Tez (Note that you might need to wait for a few seconds for the network to register the funds)`);
            } else (0, $iVZbm$taquerianodesdk.sendErr)(msg + " - There was a problem communicating with the chain. Check the RPC URL of the network or sandbox you're targeting in config.json.\n");
        }
        return undefined;
    }
};
async function $806c5c6032403442$export$e4c4fcd791db1d6b(toolkit, privateKeyOrEmail, passphrase, mnemonic, secret) {
    if (privateKeyOrEmail && passphrase && mnemonic && secret) return await (0, $iVZbm$taquitosigner.importKey)(toolkit, privateKeyOrEmail, passphrase, mnemonic, secret);
    else if (mnemonic) {
        const signer = (0, $iVZbm$taquitosigner.InMemorySigner).fromFundraiser(privateKeyOrEmail ?? "", passphrase ?? "", mnemonic);
        toolkit.setProvider({
            signer: signer
        });
        const pkh = await signer.publicKeyHash();
        let op;
        try {
            op = await toolkit.tz.activate(pkh, secret ?? "");
            if (op) await op.confirmation();
        } catch (ex) {}
    } else if (privateKeyOrEmail) {
        // Fallback to regular import
        const signer = await (0, $iVZbm$taquitosigner.InMemorySigner).fromSecretKey(privateKeyOrEmail, passphrase);
        toolkit.setProvider({
            signer: signer
        });
    }
}
const $806c5c6032403442$var$originateToNetworks = (parsedArgs, currentEnv)=>currentEnv.networks ? currentEnv.networks.reduce((retval, networkName)=>{
        const network = (0, $iVZbm$taquerianodesdk.getNetworkConfig)(parsedArgs)(networkName);
        if (network) {
            if (network.rpcUrl) {
                const result = (async ()=>{
                    const tezos = new (0, $iVZbm$taquitotaquito.TezosToolkit)(network.rpcUrl);
                    const key = await (0, $iVZbm$taquerianodesdk.getAccountPrivateKey)(parsedArgs, network, "taqRootAccount");
                    await (0, $iVZbm$taquitosigner.importKey)(tezos, key);
                    return await $806c5c6032403442$var$createBatch(parsedArgs, tezos, networkName);
                })();
                return [
                    ...retval,
                    result
                ];
            } else (0, $iVZbm$taquerianodesdk.sendErr)(`Network "${networkName}" is missing an RPC url in config.json.`);
        } else (0, $iVZbm$taquerianodesdk.sendErr)(`The current environment is configured to use a network called '${networkName}'; however, no network of this name has been configured in .taq/config.json.`);
        return retval;
    }, []) : [];
const $806c5c6032403442$var$originateToSandboxes = (parsedArgs, currentEnv)=>currentEnv.sandboxes ? currentEnv.sandboxes.reduce((retval, sandboxName)=>{
        const sandbox = (0, $iVZbm$taquerianodesdk.getSandboxConfig)(parsedArgs)(sandboxName);
        if (sandbox) {
            if (sandbox.rpcUrl) {
                let defaultAccount = (0, $iVZbm$taquerianodesdk.getDefaultAccount)(parsedArgs)(sandboxName);
                if (!defaultAccount) {
                    const first = $806c5c6032403442$var$getFirstAccountAlias(sandboxName, parsedArgs);
                    if (first) {
                        defaultAccount = (0, $iVZbm$taquerianodesdk.getSandboxAccountConfig)(parsedArgs)(sandboxName)(first);
                        // TODO: The error should be a warning, not an error. Descriptive string should not begin with 'Warning:'
                        (0, $iVZbm$taquerianodesdk.sendErr)(`Warning: A default origination account has not been specified for sandbox ${sandboxName}. Taqueria will use the account ${first} for this origination.\nA default account can be specified in .taq/config.json at JSON path: sandbox.${sandboxName}.accounts.default\n`);
                    }
                }
                if (defaultAccount) {
                    const secretKey = defaultAccount.secretKey;
                    const result = (async ()=>{
                        const tezos = new (0, $iVZbm$taquitotaquito.TezosToolkit)(sandbox.rpcUrl);
                        tezos.setProvider({
                            signer: new (0, $iVZbm$taquitosigner.InMemorySigner)(secretKey.replace(/^unencrypted:/, ""))
                        });
                        return await $806c5c6032403442$var$createBatch(parsedArgs, tezos, sandboxName);
                    })();
                    return [
                        ...retval,
                        result
                    ];
                } else (0, $iVZbm$taquerianodesdk.sendErr)(`No accounts are available for the sandbox called ${sandboxName} to perform origination.`);
            } else (0, $iVZbm$taquerianodesdk.sendErr)(`Sandbox "${sandboxName} is missing an RPC url in config.json."`);
        } else (0, $iVZbm$taquerianodesdk.sendErr)(`The current environment is configured to use a sandbox called '${sandboxName}'; however, no sandbox of this name has been configured in .taq/config.json.`);
        return retval;
    }, []) : [];
const $806c5c6032403442$export$acf571c34911f824 = (parsedArgs)=>{
    const env = (0, $iVZbm$taquerianodesdk.getCurrentEnvironmentConfig)(parsedArgs);
    if (!env) return (0, $iVZbm$taquerianodesdk.sendAsyncErr)(`There is no environment called ${parsedArgs.env} in your config.json.`);
    const jobs1 = [
        ...$806c5c6032403442$var$originateToNetworks(parsedArgs, env),
        ...$806c5c6032403442$var$originateToSandboxes(parsedArgs, env), 
    ];
    return Promise.all(jobs1).then((jobs)=>jobs.reduce((retval, originations)=>{
            return originations ? [
                ...retval,
                ...originations
            ] : retval;
        }, [])).then((results)=>results && results.length > 0 ? (0, $iVZbm$taquerianodesdk.sendJsonRes)(results) : (0, $iVZbm$taquerianodesdk.sendErr)(`No contracts originated.`));
};
var $806c5c6032403442$export$2e2bcd8739ae039 = $806c5c6032403442$export$acf571c34911f824;






const $944e64d99e99b46e$var$getFirstAccountAlias = (sandboxName, opts)=>{
    const aliases = (0, $iVZbm$taquerianodesdk.getSandboxAccountNames)(opts)(sandboxName);
    return aliases.shift();
};
const $944e64d99e99b46e$var$configureToolKitWithSandbox = async (parsedArgs, sandboxName)=>{
    const sandbox = (0, $iVZbm$taquerianodesdk.getSandboxConfig)(parsedArgs)(sandboxName);
    if (!sandbox) return (0, $iVZbm$taquerianodesdk.sendAsyncErr)(`The current environment is configured to use a sandbox called '${sandboxName}'; however, no sandbox of this name has been configured in .taq/config.json.`);
    let defaultAccount = (0, $iVZbm$taquerianodesdk.getDefaultAccount)(parsedArgs)(sandboxName);
    if (!defaultAccount) {
        const first = $944e64d99e99b46e$var$getFirstAccountAlias(sandboxName, parsedArgs);
        if (first) {
            defaultAccount = (0, $iVZbm$taquerianodesdk.getSandboxAccountConfig)(parsedArgs)(sandboxName)(first);
            (0, $iVZbm$taquerianodesdk.sendErr)(`Warning: A default account has not been specified for sandbox ${sandboxName}. Taqueria will use the account ${first} for this operation.\nA default account can be specified in .taq/config.json at JSON path: sandbox.${sandboxName}.accounts.default\n`);
        }
    }
    if (!defaultAccount) return (0, $iVZbm$taquerianodesdk.sendAsyncErr)(`No accounts are available for the sandbox called ${sandboxName} to perform the operation.`);
    const tezos = new (0, $iVZbm$taquitotaquito.TezosToolkit)(sandbox.rpcUrl);
    tezos.setProvider({
        signer: new (0, $iVZbm$taquitosigner.InMemorySigner)(defaultAccount.secretKey.replace(/^unencrypted:/, ""))
    });
    return tezos;
};
const $944e64d99e99b46e$var$configureToolKitWithNetwork = async (parsedArgs, networkName)=>{
    const network = (0, $iVZbm$taquerianodesdk.getNetworkConfig)(parsedArgs)(networkName);
    if (!network) return (0, $iVZbm$taquerianodesdk.sendAsyncErr)(`The current environment is configured to use a network called '${networkName}'; however, no network of this name has been configured in .taq/config.json.`);
    const tezos = new (0, $iVZbm$taquitotaquito.TezosToolkit)(network.rpcUrl);
    const key = await (0, $iVZbm$taquerianodesdk.getAccountPrivateKey)(parsedArgs, network, "taqRootAccount");
    await (0, $iVZbm$taquitosigner.importKey)(tezos, key);
    return tezos;
};
const $944e64d99e99b46e$var$configureTezosToolKit = (parsedArgs, env)=>{
    const targetConstraintErrMsg = "Each environment can only have one target, be it a sandbox or a network";
    if (env.sandboxes?.length === 1 && env.networks?.length === 1) return (0, $iVZbm$taquerianodesdk.sendAsyncErr)(targetConstraintErrMsg);
    if (env.sandboxes?.length === 1) return $944e64d99e99b46e$var$configureToolKitWithSandbox(parsedArgs, env.sandboxes[0]);
    if (env.networks?.length === 1) return $944e64d99e99b46e$var$configureToolKitWithNetwork(parsedArgs, env.networks[0]);
    return (0, $iVZbm$taquerianodesdk.sendAsyncErr)(targetConstraintErrMsg);
};
const $944e64d99e99b46e$var$isContractAddress = (contract)=>contract.startsWith("tz1") || contract.startsWith("tz2") || contract.startsWith("tz3") || contract.startsWith("KT1");
const $944e64d99e99b46e$var$getContractInfo = async (parsedArgs, env, tezos)=>{
    const contract = parsedArgs.contract;
    return {
        contractAlias: $944e64d99e99b46e$var$isContractAddress(contract) ? "N/A" : contract,
        contractAddress: $944e64d99e99b46e$var$isContractAddress(contract) ? contract : await (0, $iVZbm$taquerianodesdk.getAddressOfAlias)(env, contract),
        tezTransfer: parsedArgs.tez ?? "0",
        parameter: parsedArgs.param ? await (0, $iVZbm$taquerianodesdk.getParameter)(parsedArgs, parsedArgs.param) : "Unit",
        entrypoint: parsedArgs.entrypoint ?? "default",
        destination: tezos.rpc.getRpcUrl()
    };
};
const $944e64d99e99b46e$var$performTransferOp = (tezos, contractInfo, parsedArgs)=>{
    return tezos.contract.transfer({
        to: contractInfo.contractAddress,
        amount: parseFloat(contractInfo.tezTransfer),
        parameter: {
            entrypoint: contractInfo.entrypoint,
            value: new (0, $iVZbm$taquitomichelcodec.Parser)().parseMichelineExpression(contractInfo.parameter)
        }
    }).then((op)=>op.confirmation().then(()=>op.hash)).catch((err)=>{
        if (err instanceof Error) {
            if (/empty_implicit_contract/.test(err.message)) {
                const result = err.message.match(/(?<="implicit":")tz[^"]+(?=")/);
                const publicKeyHash = result ? result[0] : undefined;
                if (publicKeyHash) return (0, $iVZbm$taquerianodesdk.sendAsyncErr)(`The account ${publicKeyHash} for the target environment, "${(0, $iVZbm$taquerianodesdk.getCurrentEnvironment)(parsedArgs)}", may not be funded\nTo fund this account:\n1. Go to https://teztnets.xyz and click "Faucet" of the target testnet\n2. Copy and paste the above key into the 'wallet address field\n3. Request some Tez (Note that you might need to wait for a few seconds for the network to register the funds)`);
            }
        }
        return (0, $iVZbm$taquerianodesdk.sendAsyncErr)(`Error during transfer operation:\n${err} ${JSON.stringify(err, null, 2)}`);
    });
};
const $944e64d99e99b46e$export$c9b234447cf4ef7c = async (parsedArgs)=>{
    const env = (0, $iVZbm$taquerianodesdk.getCurrentEnvironmentConfig)(parsedArgs);
    if (!env) return (0, $iVZbm$taquerianodesdk.sendAsyncErr)(`There is no environment called ${parsedArgs.env} in your config.json.`);
    try {
        const tezos = await $944e64d99e99b46e$var$configureTezosToolKit(parsedArgs, env);
        const contractInfo = await $944e64d99e99b46e$var$getContractInfo(parsedArgs, env, tezos);
        await $944e64d99e99b46e$var$performTransferOp(tezos, contractInfo, parsedArgs);
        return (0, $iVZbm$taquerianodesdk.sendJsonRes)([
            contractInfo
        ]);
    } catch  {
        return (0, $iVZbm$taquerianodesdk.sendAsyncErr)("No operations performed.");
    }
};
var $944e64d99e99b46e$export$2e2bcd8739ae039 = $944e64d99e99b46e$export$c9b234447cf4ef7c;


const $e6ed693f861ac256$export$71d25adf06a71b9 = (parsedArgs)=>{
    switch(parsedArgs.task){
        case "originate":
        case "deploy":
            return (0, $806c5c6032403442$export$2e2bcd8739ae039)(parsedArgs);
        case "transfer":
        case "call":
            return (0, $944e64d99e99b46e$export$2e2bcd8739ae039)(parsedArgs);
        default:
            return (0, $iVZbm$taquerianodesdk.sendAsyncErr)(`${parsedArgs.task} is not an understood task by the Taquito plugin`);
    }
};
var $e6ed693f861ac256$export$2e2bcd8739ae039 = $e6ed693f861ac256$export$71d25adf06a71b9;


(0, $iVZbm$taquerianodesdk.Plugin).create((_i18n)=>({
        alias: "taquito",
        schema: "1.0",
        version: "0.1",
        tasks: [
            (0, $iVZbm$taquerianodesdk.Task).create({
                task: "deploy",
                command: "deploy <contract>",
                description: "Deploy a smart contract to a particular environment",
                options: [
                    (0, $iVZbm$taquerianodesdk.Option).create({
                        flag: "alias",
                        description: "Alias used to refer to the deployed contract's address",
                        required: false
                    }),
                    (0, $iVZbm$taquerianodesdk.Option).create({
                        flag: "storage",
                        description: "Name of the storage file that contains the storage value as a Michelson expression, in the artifacts directory, used for originating a contract",
                        required: false
                    }), 
                ],
                aliases: [
                    "originate"
                ],
                handler: "proxy",
                encoding: "application/json"
            }),
            (0, $iVZbm$taquerianodesdk.Task).create({
                task: "transfer",
                command: "transfer <contract>",
                description: "Transfer/call an implicit account or a smart contract (specified via its alias or address) deployed to a particular environment",
                options: [
                    (0, $iVZbm$taquerianodesdk.Option).create({
                        flag: "tez",
                        description: "Amount of Tez to transfer",
                        required: false
                    }),
                    (0, $iVZbm$taquerianodesdk.Option).create({
                        flag: "param",
                        description: "Name of the parameter file that contains the parameter value as a Michelson expression, in the artifacts directory, used for invoking a deployed contract",
                        required: false
                    }),
                    (0, $iVZbm$taquerianodesdk.Option).create({
                        flag: "entrypoint",
                        description: "You may explicitly specify an entrypoint to make the parameter value shorter, without having to specify a chain of (Left (Right ... 14 ...))",
                        required: false
                    }), 
                ],
                aliases: [
                    "call"
                ],
                handler: "proxy",
                encoding: "application/json"
            }), 
        ],
        proxy: (0, $e6ed693f861ac256$export$2e2bcd8739ae039)
    }), process.argv);


//# sourceMappingURL=index.js.map
