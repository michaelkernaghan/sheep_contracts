import {
  PluginSchema,
  __require
} from "./chunk-BDDBVWLM.mjs";

// index.ts
import * as Contract from "@taqueria/protocol/Contract";
import * as Environment from "@taqueria/protocol/Environment";
import load from "@taqueria/protocol/i18n";
import * as LoadedConfig from "@taqueria/protocol/LoadedConfig";
import * as MetadataConfig from "@taqueria/protocol/MetadataConfig";
import * as NetworkConfig from "@taqueria/protocol/NetworkConfig";
import * as Operation from "@taqueria/protocol/Operation";
import * as Option from "@taqueria/protocol/Option";
import * as PersistentState from "@taqueria/protocol/PersistentState";
import * as PositionalArg from "@taqueria/protocol/PositionalArg";
import * as RequestArgs from "@taqueria/protocol/RequestArgs";
import * as SandboxAccountConfig from "@taqueria/protocol/SandboxAccountConfig";
import * as SandboxConfig from "@taqueria/protocol/SandboxConfig";
import * as SHA256 from "@taqueria/protocol/SHA256";
import { E_TaqError, toFutureParseErr, toFutureParseUnknownErr } from "@taqueria/protocol/TaqError";
import * as Protocol from "@taqueria/protocol/taqueria-protocol-types";
import * as Task from "@taqueria/protocol/Task";
import * as Template from "@taqueria/protocol/Template";
import { exec } from "child_process";
import { mapRej, promise } from "fluture";
import { readFile, writeFile } from "fs/promises";
import { dirname, join } from "path";
import { getSync } from "stacktrace-js";
import { ZodError } from "zod";
import { importKey } from "@taquito/signer";
import { TezosToolkit } from "@taquito/taquito";
import { b58cencode, Prefix, prefix } from "@taquito/utils";
import crypto from "crypto";
import generateName from "project-name-generator";
var yargs = __require("yargs");
var eager = (f) => promise(
  mapRej((err) => new E_TaqError(err))(f)
);
var writeJsonFile = (filename) => (data) => writeFile(filename, JSON.stringify(data, void 0, 4), { encoding: "utf8" }).then((_) => filename);
var readJsonFile = (filename) => readFile(filename, { encoding: "utf-8" }).then(JSON.parse).then((result) => result);
var execCmd = (cmd) => new Promise((resolve, reject) => {
  exec(`sh -c "${cmd}"`, (err, stdout, stderr) => {
    if (err)
      reject(err);
    else {
      resolve({
        stdout,
        stderr
      });
    }
  });
});
var execCommandWithoutWrapping = (cmd) => new Promise((resolve, reject) => {
  exec(cmd, (err, stdout, stderr) => {
    if (err)
      reject(err);
    else {
      resolve({
        stdout,
        stderr
      });
    }
  });
});
var getArch = () => {
  switch (process.arch) {
    case "arm64":
      return Promise.resolve("linux/arm64/v8");
    case "x32":
    case "x64":
      return Promise.resolve("linux/amd64");
    default:
      return Promise.reject({
        errCode: "E_INVALID_ARCH",
        errMsg: `We do not know how to handle the ${process.arch} architecture`,
        context: process.arch
      });
  }
};
var getFlextesaImage = (arch) => arch === "linux/arm64/v8" ? "oxheadalpha/flextesa:rc-20220915-arm64" : "oxheadalpha/flextesa:20220715";
var parseJSON = (input) => new Promise((resolve, reject) => {
  try {
    const json = JSON.parse(input);
    resolve(json);
  } catch (previous) {
    const taqErr = {
      kind: "E_INVALID_JSON",
      msg: `Invalid JSON: ${input}`,
      previous,
      context: input
    };
    return reject(taqErr);
  }
});
var sendRes = (msg, newline = true) => {
  if (!msg || msg.length === 0)
    return;
  return newline ? console.log(msg) : process.stdout.write(msg);
};
var sendAsyncRes = (msg, newline = true) => Promise.resolve(sendRes(msg, newline));
var sendErr = (msg, newline = true) => {
  if (!msg || msg.length === 0)
    return;
  return newline ? console.error(msg) : process.stderr.write(msg);
};
var sendWarn = (msg, newline = true) => {
  if (!msg || msg.length === 0)
    return;
  return newline ? console.warn(msg) : process.stderr.write(msg);
};
var sendAsyncErr = (msg, newline = true) => Promise.reject(sendErr(msg, newline));
var sendJson = (msg, newline = true) => sendRes(JSON.stringify(msg), newline);
var sendJsonErr = (msg, newline = true) => sendErr(JSON.stringify(msg), newline);
var sendAsyncJson = (msg, newline = true) => sendAsyncRes(JSON.stringify(msg), newline);
var sendAsyncJsonErr = (msg, newline = true) => sendAsyncErr(JSON.stringify(msg), newline);
var sendJsonRes = (data) => typeof data === "object" ? sendJson({
  data,
  render: "table"
}) : sendJson({
  data,
  render: "string"
});
var sendAsyncJsonRes = (data) => Promise.resolve(sendJsonRes(data));
var noop = () => {
};
var parseArgs = (unparsedArgs) => {
  if (unparsedArgs && Array.isArray(unparsedArgs) && unparsedArgs.length >= 2) {
    try {
      const preprocessedArgs = preprocessArgs(unparsedArgs);
      const argv = yargs(preprocessedArgs.slice(2)).argv;
      const postprocessedArgs = postprocessArgs(argv);
      const requestArgs = RequestArgs.from(postprocessedArgs);
      return Promise.resolve(requestArgs);
    } catch (previous) {
      if (previous instanceof ZodError) {
        return eager(
          toFutureParseErr(previous, "The plugin request arguments are invalid", unparsedArgs)
        );
      }
      return eager(
        toFutureParseUnknownErr(
          previous,
          "There was a problem trying to parse the plugin request arguments",
          unparsedArgs
        )
      );
    }
  }
  return Promise.reject("Invalid usage. If you were testing your plugin, did you remember to specify --taqRun?");
};
var preprocessArgs = (args) => {
  return args.map((arg) => /^0x[0-9a-fA-F]+$/.test(arg) ? "___" + arg + "___" : arg);
};
var postprocessArgs = (args) => {
  const postprocessedArgs = Object.entries(args).map(([key, val]) => [
    key,
    typeof val === "string" && /^___0x[0-9a-fA-F]+___$/.test(val) ? val.slice(3, -3) : val
  ]);
  const groupedArgs = postprocessedArgs.reduce(
    (acc, arg) => {
      const key = arg[0];
      const val = arg[1];
      return { ...acc, [key]: val };
    },
    {}
  );
  return groupedArgs;
};
var parseSchema = (i18n, definer, defaultPluginName, requestArgs) => {
  const inputSchema = definer(requestArgs, i18n);
  const { proxy } = inputSchema;
  const pluginInfo = PluginSchema.create({
    ...inputSchema,
    name: inputSchema.name ?? defaultPluginName
  });
  return {
    ...pluginInfo,
    proxy
  };
};
var getResponse = (definer, defaultPluginName) => async (requestArgs) => {
  var _a;
  const { taqRun } = requestArgs;
  const i18n = await load();
  const schema = parseSchema(i18n, definer, defaultPluginName, requestArgs);
  try {
    switch (taqRun) {
      case "pluginInfo":
        const output = {
          ...schema,
          templates: schema.templates ? schema.templates.map(
            (template) => {
              const handler = typeof template.handler === "function" ? "function" : template.handler;
              return {
                ...template,
                handler
              };
            }
          ) : [],
          tasks: schema.tasks ? schema.tasks.map(
            (task) => {
              const handler = typeof task.handler === "function" ? "function" : task.handler;
              return {
                ...task,
                handler
              };
            }
          ) : [],
          proxy: schema.proxy ? true : false,
          checkRuntimeDependencies: schema.checkRuntimeDependencies ? true : false,
          installRuntimeDependencies: schema.installRuntimeDependencies ? true : false
        };
        return sendAsyncJson(output);
      case "proxy":
        if (schema.proxy) {
          const retval = schema.proxy(RequestArgs.createProxyRequestArgs(requestArgs));
          if (retval)
            return retval;
          return Promise.reject({
            errCode: "E_PROXY",
            message: "The plugin's proxy method must return a promise.",
            context: retval
          });
        }
        return Promise.reject({
          errCode: "E_NOT_SUPPORTED",
          message: i18n.__("proxyNotSupported"),
          context: requestArgs
        });
      case "proxyTemplate": {
        const proxyArgs = RequestArgs.createProxyTemplateRequestArgs(requestArgs);
        const template = (_a = schema.templates) == null ? void 0 : _a.find((tmpl) => tmpl.template === proxyArgs.template);
        if (template) {
          if (typeof template.handler === "function") {
            return template.handler(proxyArgs);
          }
          return Promise.reject({
            errCode: "E_NOT_SUPPORTED",
            message: i18n.__("proxyNotSupported"),
            context: requestArgs
          });
        }
        return Promise.reject({
          errCode: "E_INVALID_TEMPLATE",
          message: i18n.__("invalidTemplate"),
          context: requestArgs
        });
      }
      case "checkRuntimeDependencies":
        return sendAsyncJson(
          schema.checkRuntimeDependencies ? schema.checkRuntimeDependencies(i18n, requestArgs) : Promise.resolve({ report: [] })
        );
      case "installRuntimeDependencies":
        return sendAsyncJson(
          schema.installRuntimeDependencies ? schema.installRuntimeDependencies(i18n, requestArgs) : Promise.resolve({ report: [] })
        );
      default:
        return Promise.reject({
          errCode: "E_NOT_SUPPORTED",
          message: i18n.__("actionNotSupported"),
          context: requestArgs
        });
    }
  } catch (previous) {
    return Promise.reject({
      errCode: "E_UNEXPECTED",
      message: "The plugin encountered a fatal error",
      previous
    });
  }
};
var getNameFromPluginManifest = (packageJsonAbspath) => {
  try {
    return `${__require(packageJsonAbspath).name}`;
  } catch (_) {
    return generateName().dashed;
  }
};
var getCurrentEnvironment = (parsedArgs) => {
  return parsedArgs.env ? parsedArgs.env : parsedArgs.config.environment ? parsedArgs.config.environment.default : "development";
};
var getCurrentEnvironmentConfig = (parsedArgs) => {
  const currentEnv = getCurrentEnvironment(parsedArgs);
  return parsedArgs.config.environment && parsedArgs.config.environment[currentEnv] ? parsedArgs.config.environment[currentEnv] : void 0;
};
var getMetadataConfig = (parsedArgs) => () => parsedArgs.config.metadata ?? void 0;
var getNetworkConfig = (parsedArgs) => (networkName) => parsedArgs.config.network[networkName] ?? void 0;
var getSandboxConfig = (parsedArgs) => (sandboxName) => parsedArgs.config.sandbox[sandboxName] ?? void 0;
var getSandboxAccountNames = (parsedArgs) => (sandboxName) => {
  const sandbox = getSandboxConfig(parsedArgs)(sandboxName);
  return sandbox ? Object.keys(sandbox.accounts ?? []).filter((accountName) => accountName !== "default") : [];
};
var getSandboxAccountConfig = (parsedArgs) => (sandboxName) => (accountName) => {
  const sandbox = getSandboxConfig(parsedArgs)(sandboxName);
  if (sandbox && sandbox.accounts) {
    const accounts = sandbox.accounts;
    return accounts[accountName];
  }
  return void 0;
};
var getInitialStorage = async (parsedArgs, contractFilename) => {
  const env = getCurrentEnvironmentConfig(parsedArgs);
  if (env && env.storage && env.storage[contractFilename]) {
    const storagePath = env.storage[contractFilename];
    try {
      const content = await readFile(storagePath, { encoding: "utf-8" });
      return content;
    } catch (err) {
      sendErr(`Could not read ${storagePath}. Maybe it doesn't exist.
`);
      return void 0;
    }
  }
  return void 0;
};
var newGetInitialStorage = async (parsedArgs, storageFilename) => {
  const storagePath = join(parsedArgs.config.projectDir, parsedArgs.config.artifactsDir, storageFilename);
  try {
    const content = await readFile(storagePath, { encoding: "utf-8" });
    return content;
  } catch (err) {
    sendErr(`Could not read ${storagePath}. Maybe it doesn't exist.
`);
    return void 0;
  }
};
var getParameter = async (parsedArgs, paramFilename) => {
  const paramPath = join(parsedArgs.config.projectDir, parsedArgs.config.artifactsDir, paramFilename);
  try {
    const content = await readFile(paramPath, { encoding: "utf-8" });
    return content;
  } catch (err) {
    return sendAsyncErr(`Could not read ${paramPath}. Maybe it doesn't exist.`);
  }
};
var updateAddressAlias = async (parsedArgs, alias, address) => {
  const env = getCurrentEnvironmentConfig(parsedArgs);
  if (!env)
    return;
  if (!env.aliases) {
    env.aliases = { [alias]: { address } };
  } else if (!env.aliases[alias]) {
    env.aliases[alias] = { address };
  } else {
    env.aliases[alias].address = address;
  }
  try {
    await writeJsonFile("./.taq/config.json")(parsedArgs.config);
  } catch (err) {
    sendErr(`Could not write to ./.taq/config.json
`);
  }
};
var getAddressOfAlias = async (env, alias) => {
  var _a, _b;
  const address = (_b = (_a = env.aliases) == null ? void 0 : _a[alias]) == null ? void 0 : _b.address;
  if (!address) {
    return sendAsyncErr(
      `Address for alias "${alias}" is not present in the config.json. Make sure to deploy a contract with such alias.`
    );
  }
  return address;
};
var createAddress = async (network) => {
  const tezos = new TezosToolkit(network.rpcUrl);
  const keyBytes = Buffer.alloc(32);
  crypto.randomFillSync(keyBytes);
  const key = b58cencode(new Uint8Array(keyBytes), prefix[Prefix.P2SK]);
  await importKey(tezos, key);
  return tezos;
};
var getAccountPrivateKey = async (parsedArgs, network, account) => {
  if (!network.accounts)
    network.accounts = {};
  if (!network.accounts[account]) {
    const tezos = await createAddress(network);
    const publicKey = await tezos.signer.publicKey();
    const publicKeyHash = await tezos.signer.publicKeyHash();
    const privateKey = await tezos.signer.secretKey();
    if (!privateKey)
      return sendAsyncErr("The private key must exist after creating it");
    network.accounts[account] = { publicKey, publicKeyHash, privateKey };
    try {
      await writeJsonFile("./.taq/config.json")(parsedArgs.config);
    } catch (err) {
      return sendAsyncErr(`Could not write to ./.taq/config.json
`);
    }
    return sendAsyncErr(
      `A keypair with public key hash ${network.accounts[account].publicKeyHash} was generated for you.
To fund this account:
1. Go to https://teztnets.xyz and click "Faucet" of the target testnet
2. Copy and paste the above key into the 'wallet address field
3. Request some Tez (Note that you might need to wait for a few seconds for the network to register the funds)`
    );
  }
  return network.accounts[account].privateKey;
};
var getDefaultAccount = (parsedArgs) => (sandboxName) => {
  const sandboxConfig = getSandboxConfig(parsedArgs)(sandboxName);
  if (sandboxConfig) {
    const accounts = sandboxConfig.accounts ?? {};
    const defaultAccount = accounts["default"];
    if (defaultAccount) {
      return getSandboxAccountConfig(parsedArgs)(sandboxName)(defaultAccount);
    }
  }
  return void 0;
};
var getContracts = (regex, config) => {
  if (!config.contracts)
    return [];
  return Object.values(config.contracts).reduce(
    (retval, contract) => regex.test(contract.sourceFile) ? [...retval, contract.sourceFile] : retval,
    []
  );
};
var joinPaths = (...paths) => paths.join("/");
var newContract = async (sourceFile, parsedArgs) => {
  const contractPath = joinPaths(parsedArgs.projectDir, parsedArgs.config.contractsDir, sourceFile);
  try {
    const contents = await readFile(contractPath, { encoding: "utf-8" });
    const hash = await SHA256.toSHA256(contents);
    return await eager(Contract.of({
      sourceFile,
      hash
    }));
  } catch (err) {
    await Promise.reject(`Could not read ${contractPath}`);
  }
};
var registerContract = async (parsedArgs, sourceFile) => {
  try {
    const config = await readJsonFile(parsedArgs.config.configFile);
    if (config.contracts && config.contracts[sourceFile]) {
      await sendAsyncErr(`${sourceFile} has already been registered`);
    } else {
      const contract = await newContract(sourceFile, parsedArgs);
      const contracts = config.contracts || {};
      const updatedConfig = {
        ...config,
        contracts: {
          ...contracts,
          ...Object.fromEntries([[sourceFile, contract]])
        }
      };
      await writeJsonFile(parsedArgs.config.configFile)(updatedConfig);
    }
  } catch (err) {
    if (err)
      console.error("Error registering contract:", err);
  }
};
var stringToSHA256 = (s) => SHA256.toSHA256(s);
var getPackageName = () => {
  const stack = getSync({
    filter: (stackFrame) => {
      const filename = stackFrame.getFileName();
      return !filename.includes("taqueria-sdk") && !filename.includes("@taqueria/node-sdk") && !filename.includes("stacktrace-js");
    }
  });
  const frame = stack.shift();
  if (frame) {
    const filename = frame.getFileName().replace(/^file:\/\//, "").replace(/^file:/, "");
    const pluginManifest = join(dirname(filename), "package.json");
    return getNameFromPluginManifest(pluginManifest);
  }
  return generateName().dashed;
};
var Plugin = {
  create: async (definer, unparsedArgs) => {
    const packageName = getPackageName();
    return parseArgs(unparsedArgs).then(getResponse(definer, packageName)).catch((err) => {
      if (err)
        console.error(err);
      process.exit(1);
    });
  }
};
var experimental = {
  registerContract
};
export {
  Environment,
  LoadedConfig,
  MetadataConfig,
  NetworkConfig,
  Operation,
  Option,
  PersistentState,
  Plugin,
  PositionalArg,
  Protocol,
  SandboxAccountConfig,
  SandboxConfig,
  Task,
  Template,
  eager,
  execCmd,
  execCommandWithoutWrapping,
  experimental,
  getAccountPrivateKey,
  getAddressOfAlias,
  getArch,
  getContracts,
  getCurrentEnvironment,
  getCurrentEnvironmentConfig,
  getDefaultAccount,
  getFlextesaImage,
  getInitialStorage,
  getMetadataConfig,
  getNetworkConfig,
  getParameter,
  getSandboxAccountConfig,
  getSandboxAccountNames,
  getSandboxConfig,
  newGetInitialStorage,
  noop,
  parseJSON,
  readJsonFile,
  sendAsyncErr,
  sendAsyncJson,
  sendAsyncJsonErr,
  sendAsyncJsonRes,
  sendAsyncRes,
  sendErr,
  sendJson,
  sendJsonErr,
  sendJsonRes,
  sendRes,
  sendWarn,
  stringToSHA256,
  updateAddressAlias,
  writeJsonFile
};
//# sourceMappingURL=index.mjs.map