"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// index.ts
var taqueria_sdk_exports = {};
__export(taqueria_sdk_exports, {
  Environment: () => Environment2,
  LoadedConfig: () => LoadedConfig2,
  MetadataConfig: () => MetadataConfig2,
  NetworkConfig: () => NetworkConfig2,
  Operation: () => Operation2,
  Option: () => Option2,
  PersistentState: () => PersistentState2,
  Plugin: () => Plugin,
  PositionalArg: () => PositionalArg2,
  Protocol: () => Protocol2,
  SandboxAccountConfig: () => SandboxAccountConfig2,
  SandboxConfig: () => SandboxConfig2,
  Task: () => Task2,
  Template: () => Template2,
  eager: () => eager,
  execCmd: () => execCmd,
  execCommandWithoutWrapping: () => execCommandWithoutWrapping,
  experimental: () => experimental,
  getAccountPrivateKey: () => getAccountPrivateKey,
  getAddressOfAlias: () => getAddressOfAlias,
  getArch: () => getArch,
  getContracts: () => getContracts,
  getCurrentEnvironment: () => getCurrentEnvironment,
  getCurrentEnvironmentConfig: () => getCurrentEnvironmentConfig,
  getDefaultAccount: () => getDefaultAccount,
  getFlextesaImage: () => getFlextesaImage,
  getInitialStorage: () => getInitialStorage,
  getMetadataConfig: () => getMetadataConfig,
  getNetworkConfig: () => getNetworkConfig,
  getParameter: () => getParameter,
  getSandboxAccountConfig: () => getSandboxAccountConfig,
  getSandboxAccountNames: () => getSandboxAccountNames,
  getSandboxConfig: () => getSandboxConfig,
  newGetInitialStorage: () => newGetInitialStorage,
  noop: () => noop,
  parseJSON: () => parseJSON,
  readJsonFile: () => readJsonFile,
  sendAsyncErr: () => sendAsyncErr,
  sendAsyncJson: () => sendAsyncJson,
  sendAsyncJsonErr: () => sendAsyncJsonErr,
  sendAsyncJsonRes: () => sendAsyncJsonRes,
  sendAsyncRes: () => sendAsyncRes,
  sendErr: () => sendErr,
  sendJson: () => sendJson,
  sendJsonErr: () => sendJsonErr,
  sendJsonRes: () => sendJsonRes,
  sendRes: () => sendRes,
  sendWarn: () => sendWarn,
  stringToSHA256: () => stringToSHA256,
  updateAddressAlias: () => updateAddressAlias,
  writeJsonFile: () => writeJsonFile
});
module.exports = __toCommonJS(taqueria_sdk_exports);
var Contract = __toESM(require("@taqueria/protocol/Contract"));
var Environment2 = __toESM(require("@taqueria/protocol/Environment"));
var import_i18n = __toESM(require("@taqueria/protocol/i18n"));
var LoadedConfig2 = __toESM(require("@taqueria/protocol/LoadedConfig"));
var MetadataConfig2 = __toESM(require("@taqueria/protocol/MetadataConfig"));
var NetworkConfig2 = __toESM(require("@taqueria/protocol/NetworkConfig"));
var Operation2 = __toESM(require("@taqueria/protocol/Operation"));
var Option2 = __toESM(require("@taqueria/protocol/Option"));
var PersistentState2 = __toESM(require("@taqueria/protocol/PersistentState"));
var PositionalArg2 = __toESM(require("@taqueria/protocol/PositionalArg"));
var RequestArgs2 = __toESM(require("@taqueria/protocol/RequestArgs"));
var SandboxAccountConfig2 = __toESM(require("@taqueria/protocol/SandboxAccountConfig"));
var SandboxConfig2 = __toESM(require("@taqueria/protocol/SandboxConfig"));
var SHA256 = __toESM(require("@taqueria/protocol/SHA256"));
var import_TaqError = require("@taqueria/protocol/TaqError");
var Protocol2 = __toESM(require("@taqueria/protocol/taqueria-protocol-types"));
var Task2 = __toESM(require("@taqueria/protocol/Task"));
var Template2 = __toESM(require("@taqueria/protocol/Template"));
var import_child_process = require("child_process");
var import_fluture = require("fluture");
var import_promises = require("fs/promises");
var import_path = require("path");
var import_stacktrace_js = require("stacktrace-js");
var import_zod = require("zod");

// types.ts
var Environment = __toESM(require("@taqueria/protocol/Environment"));
var LoadedConfig = __toESM(require("@taqueria/protocol/LoadedConfig"));
var MetadataConfig = __toESM(require("@taqueria/protocol/MetadataConfig"));
var NetworkConfig = __toESM(require("@taqueria/protocol/NetworkConfig"));
var Operation = __toESM(require("@taqueria/protocol/Operation"));
var Option = __toESM(require("@taqueria/protocol/Option"));
var PersistentState = __toESM(require("@taqueria/protocol/PersistentState"));
var PluginSchema = __toESM(require("@taqueria/protocol/PluginSchema"));
var PositionalArg = __toESM(require("@taqueria/protocol/PositionalArg"));
var RequestArgs = __toESM(require("@taqueria/protocol/RequestArgs"));
var SandboxAccountConfig = __toESM(require("@taqueria/protocol/SandboxAccountConfig"));
var SandboxConfig = __toESM(require("@taqueria/protocol/SandboxConfig"));
var SanitizedAbsPath = __toESM(require("@taqueria/protocol/SanitizedAbsPath"));
var SanitizedPath = __toESM(require("@taqueria/protocol/SanitizedPath"));
var TaqError = __toESM(require("@taqueria/protocol/TaqError"));
var Protocol = __toESM(require("@taqueria/protocol/taqueria-protocol-types"));
var Task = __toESM(require("@taqueria/protocol/Task"));
var Template = __toESM(require("@taqueria/protocol/Template"));

// index.ts
var import_signer = require("@taquito/signer");
var import_taquito = require("@taquito/taquito");
var import_utils = require("@taquito/utils");
var import_crypto = __toESM(require("crypto"));
var import_project_name_generator = __toESM(require("project-name-generator"));
var yargs = require("yargs");
var eager = (f) => (0, import_fluture.promise)(
  (0, import_fluture.mapRej)((err) => new import_TaqError.E_TaqError(err))(f)
);
var writeJsonFile = (filename) => (data) => (0, import_promises.writeFile)(filename, JSON.stringify(data, void 0, 4), { encoding: "utf8" }).then((_) => filename);
var readJsonFile = (filename) => (0, import_promises.readFile)(filename, { encoding: "utf-8" }).then(JSON.parse).then((result) => result);
var execCmd = (cmd) => new Promise((resolve, reject) => {
  (0, import_child_process.exec)(`sh -c "${cmd}"`, (err, stdout, stderr) => {
    if (err)
      reject(err);
    else {
      resolve({
        stdout,
        stderr
      });
    }
  });
});
var execCommandWithoutWrapping = (cmd) => new Promise((resolve, reject) => {
  (0, import_child_process.exec)(cmd, (err, stdout, stderr) => {
    if (err)
      reject(err);
    else {
      resolve({
        stdout,
        stderr
      });
    }
  });
});
var getArch = () => {
  switch (process.arch) {
    case "arm64":
      return Promise.resolve("linux/arm64/v8");
    case "x32":
    case "x64":
      return Promise.resolve("linux/amd64");
    default:
      return Promise.reject({
        errCode: "E_INVALID_ARCH",
        errMsg: `We do not know how to handle the ${process.arch} architecture`,
        context: process.arch
      });
  }
};
var getFlextesaImage = (arch) => arch === "linux/arm64/v8" ? "oxheadalpha/flextesa:rc-20220915-arm64" : "oxheadalpha/flextesa:20220715";
var parseJSON = (input) => new Promise((resolve, reject) => {
  try {
    const json = JSON.parse(input);
    resolve(json);
  } catch (previous) {
    const taqErr = {
      kind: "E_INVALID_JSON",
      msg: `Invalid JSON: ${input}`,
      previous,
      context: input
    };
    return reject(taqErr);
  }
});
var sendRes = (msg, newline = true) => {
  if (!msg || msg.length === 0)
    return;
  return newline ? console.log(msg) : process.stdout.write(msg);
};
var sendAsyncRes = (msg, newline = true) => Promise.resolve(sendRes(msg, newline));
var sendErr = (msg, newline = true) => {
  if (!msg || msg.length === 0)
    return;
  return newline ? console.error(msg) : process.stderr.write(msg);
};
var sendWarn = (msg, newline = true) => {
  if (!msg || msg.length === 0)
    return;
  return newline ? console.warn(msg) : process.stderr.write(msg);
};
var sendAsyncErr = (msg, newline = true) => Promise.reject(sendErr(msg, newline));
var sendJson = (msg, newline = true) => sendRes(JSON.stringify(msg), newline);
var sendJsonErr = (msg, newline = true) => sendErr(JSON.stringify(msg), newline);
var sendAsyncJson = (msg, newline = true) => sendAsyncRes(JSON.stringify(msg), newline);
var sendAsyncJsonErr = (msg, newline = true) => sendAsyncErr(JSON.stringify(msg), newline);
var sendJsonRes = (data) => typeof data === "object" ? sendJson({
  data,
  render: "table"
}) : sendJson({
  data,
  render: "string"
});
var sendAsyncJsonRes = (data) => Promise.resolve(sendJsonRes(data));
var noop = () => {
};
var parseArgs = (unparsedArgs) => {
  if (unparsedArgs && Array.isArray(unparsedArgs) && unparsedArgs.length >= 2) {
    try {
      const preprocessedArgs = preprocessArgs(unparsedArgs);
      const argv = yargs(preprocessedArgs.slice(2)).argv;
      const postprocessedArgs = postprocessArgs(argv);
      const requestArgs = RequestArgs2.from(postprocessedArgs);
      return Promise.resolve(requestArgs);
    } catch (previous) {
      if (previous instanceof import_zod.ZodError) {
        return eager(
          (0, import_TaqError.toFutureParseErr)(previous, "The plugin request arguments are invalid", unparsedArgs)
        );
      }
      return eager(
        (0, import_TaqError.toFutureParseUnknownErr)(
          previous,
          "There was a problem trying to parse the plugin request arguments",
          unparsedArgs
        )
      );
    }
  }
  return Promise.reject("Invalid usage. If you were testing your plugin, did you remember to specify --taqRun?");
};
var preprocessArgs = (args) => {
  return args.map((arg) => /^0x[0-9a-fA-F]+$/.test(arg) ? "___" + arg + "___" : arg);
};
var postprocessArgs = (args) => {
  const postprocessedArgs = Object.entries(args).map(([key, val]) => [
    key,
    typeof val === "string" && /^___0x[0-9a-fA-F]+___$/.test(val) ? val.slice(3, -3) : val
  ]);
  const groupedArgs = postprocessedArgs.reduce(
    (acc, arg) => {
      const key = arg[0];
      const val = arg[1];
      return { ...acc, [key]: val };
    },
    {}
  );
  return groupedArgs;
};
var parseSchema = (i18n, definer, defaultPluginName, requestArgs) => {
  const inputSchema = definer(requestArgs, i18n);
  const { proxy } = inputSchema;
  const pluginInfo = PluginSchema.create({
    ...inputSchema,
    name: inputSchema.name ?? defaultPluginName
  });
  return {
    ...pluginInfo,
    proxy
  };
};
var getResponse = (definer, defaultPluginName) => async (requestArgs) => {
  var _a;
  const { taqRun } = requestArgs;
  const i18n = await (0, import_i18n.default)();
  const schema = parseSchema(i18n, definer, defaultPluginName, requestArgs);
  try {
    switch (taqRun) {
      case "pluginInfo":
        const output = {
          ...schema,
          templates: schema.templates ? schema.templates.map(
            (template) => {
              const handler = typeof template.handler === "function" ? "function" : template.handler;
              return {
                ...template,
                handler
              };
            }
          ) : [],
          tasks: schema.tasks ? schema.tasks.map(
            (task) => {
              const handler = typeof task.handler === "function" ? "function" : task.handler;
              return {
                ...task,
                handler
              };
            }
          ) : [],
          proxy: schema.proxy ? true : false,
          checkRuntimeDependencies: schema.checkRuntimeDependencies ? true : false,
          installRuntimeDependencies: schema.installRuntimeDependencies ? true : false
        };
        return sendAsyncJson(output);
      case "proxy":
        if (schema.proxy) {
          const retval = schema.proxy(RequestArgs2.createProxyRequestArgs(requestArgs));
          if (retval)
            return retval;
          return Promise.reject({
            errCode: "E_PROXY",
            message: "The plugin's proxy method must return a promise.",
            context: retval
          });
        }
        return Promise.reject({
          errCode: "E_NOT_SUPPORTED",
          message: i18n.__("proxyNotSupported"),
          context: requestArgs
        });
      case "proxyTemplate": {
        const proxyArgs = RequestArgs2.createProxyTemplateRequestArgs(requestArgs);
        const template = (_a = schema.templates) == null ? void 0 : _a.find((tmpl) => tmpl.template === proxyArgs.template);
        if (template) {
          if (typeof template.handler === "function") {
            return template.handler(proxyArgs);
          }
          return Promise.reject({
            errCode: "E_NOT_SUPPORTED",
            message: i18n.__("proxyNotSupported"),
            context: requestArgs
          });
        }
        return Promise.reject({
          errCode: "E_INVALID_TEMPLATE",
          message: i18n.__("invalidTemplate"),
          context: requestArgs
        });
      }
      case "checkRuntimeDependencies":
        return sendAsyncJson(
          schema.checkRuntimeDependencies ? schema.checkRuntimeDependencies(i18n, requestArgs) : Promise.resolve({ report: [] })
        );
      case "installRuntimeDependencies":
        return sendAsyncJson(
          schema.installRuntimeDependencies ? schema.installRuntimeDependencies(i18n, requestArgs) : Promise.resolve({ report: [] })
        );
      default:
        return Promise.reject({
          errCode: "E_NOT_SUPPORTED",
          message: i18n.__("actionNotSupported"),
          context: requestArgs
        });
    }
  } catch (previous) {
    return Promise.reject({
      errCode: "E_UNEXPECTED",
      message: "The plugin encountered a fatal error",
      previous
    });
  }
};
var getNameFromPluginManifest = (packageJsonAbspath) => {
  try {
    return `${require(packageJsonAbspath).name}`;
  } catch (_) {
    return (0, import_project_name_generator.default)().dashed;
  }
};
var getCurrentEnvironment = (parsedArgs) => {
  return parsedArgs.env ? parsedArgs.env : parsedArgs.config.environment ? parsedArgs.config.environment.default : "development";
};
var getCurrentEnvironmentConfig = (parsedArgs) => {
  const currentEnv = getCurrentEnvironment(parsedArgs);
  return parsedArgs.config.environment && parsedArgs.config.environment[currentEnv] ? parsedArgs.config.environment[currentEnv] : void 0;
};
var getMetadataConfig = (parsedArgs) => () => parsedArgs.config.metadata ?? void 0;
var getNetworkConfig = (parsedArgs) => (networkName) => parsedArgs.config.network[networkName] ?? void 0;
var getSandboxConfig = (parsedArgs) => (sandboxName) => parsedArgs.config.sandbox[sandboxName] ?? void 0;
var getSandboxAccountNames = (parsedArgs) => (sandboxName) => {
  const sandbox = getSandboxConfig(parsedArgs)(sandboxName);
  return sandbox ? Object.keys(sandbox.accounts ?? []).filter((accountName) => accountName !== "default") : [];
};
var getSandboxAccountConfig = (parsedArgs) => (sandboxName) => (accountName) => {
  const sandbox = getSandboxConfig(parsedArgs)(sandboxName);
  if (sandbox && sandbox.accounts) {
    const accounts = sandbox.accounts;
    return accounts[accountName];
  }
  return void 0;
};
var getInitialStorage = async (parsedArgs, contractFilename) => {
  const env = getCurrentEnvironmentConfig(parsedArgs);
  if (env && env.storage && env.storage[contractFilename]) {
    const storagePath = env.storage[contractFilename];
    try {
      const content = await (0, import_promises.readFile)(storagePath, { encoding: "utf-8" });
      return content;
    } catch (err) {
      sendErr(`Could not read ${storagePath}. Maybe it doesn't exist.
`);
      return void 0;
    }
  }
  return void 0;
};
var newGetInitialStorage = async (parsedArgs, storageFilename) => {
  const storagePath = (0, import_path.join)(parsedArgs.config.projectDir, parsedArgs.config.artifactsDir, storageFilename);
  try {
    const content = await (0, import_promises.readFile)(storagePath, { encoding: "utf-8" });
    return content;
  } catch (err) {
    sendErr(`Could not read ${storagePath}. Maybe it doesn't exist.
`);
    return void 0;
  }
};
var getParameter = async (parsedArgs, paramFilename) => {
  const paramPath = (0, import_path.join)(parsedArgs.config.projectDir, parsedArgs.config.artifactsDir, paramFilename);
  try {
    const content = await (0, import_promises.readFile)(paramPath, { encoding: "utf-8" });
    return content;
  } catch (err) {
    return sendAsyncErr(`Could not read ${paramPath}. Maybe it doesn't exist.`);
  }
};
var updateAddressAlias = async (parsedArgs, alias, address) => {
  const env = getCurrentEnvironmentConfig(parsedArgs);
  if (!env)
    return;
  if (!env.aliases) {
    env.aliases = { [alias]: { address } };
  } else if (!env.aliases[alias]) {
    env.aliases[alias] = { address };
  } else {
    env.aliases[alias].address = address;
  }
  try {
    await writeJsonFile("./.taq/config.json")(parsedArgs.config);
  } catch (err) {
    sendErr(`Could not write to ./.taq/config.json
`);
  }
};
var getAddressOfAlias = async (env, alias) => {
  var _a, _b;
  const address = (_b = (_a = env.aliases) == null ? void 0 : _a[alias]) == null ? void 0 : _b.address;
  if (!address) {
    return sendAsyncErr(
      `Address for alias "${alias}" is not present in the config.json. Make sure to deploy a contract with such alias.`
    );
  }
  return address;
};
var createAddress = async (network) => {
  const tezos = new import_taquito.TezosToolkit(network.rpcUrl);
  const keyBytes = Buffer.alloc(32);
  import_crypto.default.randomFillSync(keyBytes);
  const key = (0, import_utils.b58cencode)(new Uint8Array(keyBytes), import_utils.prefix[import_utils.Prefix.P2SK]);
  await (0, import_signer.importKey)(tezos, key);
  return tezos;
};
var getAccountPrivateKey = async (parsedArgs, network, account) => {
  if (!network.accounts)
    network.accounts = {};
  if (!network.accounts[account]) {
    const tezos = await createAddress(network);
    const publicKey = await tezos.signer.publicKey();
    const publicKeyHash = await tezos.signer.publicKeyHash();
    const privateKey = await tezos.signer.secretKey();
    if (!privateKey)
      return sendAsyncErr("The private key must exist after creating it");
    network.accounts[account] = { publicKey, publicKeyHash, privateKey };
    try {
      await writeJsonFile("./.taq/config.json")(parsedArgs.config);
    } catch (err) {
      return sendAsyncErr(`Could not write to ./.taq/config.json
`);
    }
    return sendAsyncErr(
      `A keypair with public key hash ${network.accounts[account].publicKeyHash} was generated for you.
To fund this account:
1. Go to https://teztnets.xyz and click "Faucet" of the target testnet
2. Copy and paste the above key into the 'wallet address field
3. Request some Tez (Note that you might need to wait for a few seconds for the network to register the funds)`
    );
  }
  return network.accounts[account].privateKey;
};
var getDefaultAccount = (parsedArgs) => (sandboxName) => {
  const sandboxConfig = getSandboxConfig(parsedArgs)(sandboxName);
  if (sandboxConfig) {
    const accounts = sandboxConfig.accounts ?? {};
    const defaultAccount = accounts["default"];
    if (defaultAccount) {
      return getSandboxAccountConfig(parsedArgs)(sandboxName)(defaultAccount);
    }
  }
  return void 0;
};
var getContracts = (regex, config) => {
  if (!config.contracts)
    return [];
  return Object.values(config.contracts).reduce(
    (retval, contract) => regex.test(contract.sourceFile) ? [...retval, contract.sourceFile] : retval,
    []
  );
};
var joinPaths = (...paths) => paths.join("/");
var newContract = async (sourceFile, parsedArgs) => {
  const contractPath = joinPaths(parsedArgs.projectDir, parsedArgs.config.contractsDir, sourceFile);
  try {
    const contents = await (0, import_promises.readFile)(contractPath, { encoding: "utf-8" });
    const hash = await SHA256.toSHA256(contents);
    return await eager(Contract.of({
      sourceFile,
      hash
    }));
  } catch (err) {
    await Promise.reject(`Could not read ${contractPath}`);
  }
};
var registerContract = async (parsedArgs, sourceFile) => {
  try {
    const config = await readJsonFile(parsedArgs.config.configFile);
    if (config.contracts && config.contracts[sourceFile]) {
      await sendAsyncErr(`${sourceFile} has already been registered`);
    } else {
      const contract = await newContract(sourceFile, parsedArgs);
      const contracts = config.contracts || {};
      const updatedConfig = {
        ...config,
        contracts: {
          ...contracts,
          ...Object.fromEntries([[sourceFile, contract]])
        }
      };
      await writeJsonFile(parsedArgs.config.configFile)(updatedConfig);
    }
  } catch (err) {
    if (err)
      console.error("Error registering contract:", err);
  }
};
var stringToSHA256 = (s) => SHA256.toSHA256(s);
var getPackageName = () => {
  const stack = (0, import_stacktrace_js.getSync)({
    filter: (stackFrame) => {
      const filename = stackFrame.getFileName();
      return !filename.includes("taqueria-sdk") && !filename.includes("@taqueria/node-sdk") && !filename.includes("stacktrace-js");
    }
  });
  const frame = stack.shift();
  if (frame) {
    const filename = frame.getFileName().replace(/^file:\/\//, "").replace(/^file:/, "");
    const pluginManifest = (0, import_path.join)((0, import_path.dirname)(filename), "package.json");
    return getNameFromPluginManifest(pluginManifest);
  }
  return (0, import_project_name_generator.default)().dashed;
};
var Plugin = {
  create: async (definer, unparsedArgs) => {
    const packageName = getPackageName();
    return parseArgs(unparsedArgs).then(getResponse(definer, packageName)).catch((err) => {
      if (err)
        console.error(err);
      process.exit(1);
    });
  }
};
var experimental = {
  registerContract
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Environment,
  LoadedConfig,
  MetadataConfig,
  NetworkConfig,
  Operation,
  Option,
  PersistentState,
  Plugin,
  PositionalArg,
  Protocol,
  SandboxAccountConfig,
  SandboxConfig,
  Task,
  Template,
  eager,
  execCmd,
  execCommandWithoutWrapping,
  experimental,
  getAccountPrivateKey,
  getAddressOfAlias,
  getArch,
  getContracts,
  getCurrentEnvironment,
  getCurrentEnvironmentConfig,
  getDefaultAccount,
  getFlextesaImage,
  getInitialStorage,
  getMetadataConfig,
  getNetworkConfig,
  getParameter,
  getSandboxAccountConfig,
  getSandboxAccountNames,
  getSandboxConfig,
  newGetInitialStorage,
  noop,
  parseJSON,
  readJsonFile,
  sendAsyncErr,
  sendAsyncJson,
  sendAsyncJsonErr,
  sendAsyncJsonRes,
  sendAsyncRes,
  sendErr,
  sendJson,
  sendJsonErr,
  sendJsonRes,
  sendRes,
  sendWarn,
  stringToSHA256,
  updateAddressAlias,
  writeJsonFile
});
//# sourceMappingURL=index.js.map